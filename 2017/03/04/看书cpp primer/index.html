<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>看书cpp primer | ptbws</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">看书cpp primer</h1><a id="logo" href="/.">ptbws</a><p class="description">观察 阅读 思考</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-book"> 痕迹</i></a><a href="/" class="current"><i class="fa undefined"> </i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">看书cpp primer</h1><div class="post-meta">Mar 4, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-Variables-and-Basic-types"><span class="toc-number">1.</span> <span class="toc-text">Chapter 2. Variables and Basic types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Compound-types"><span class="toc-number">1.1.</span> <span class="toc-text">2.3 Compound types:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reference"><span class="toc-number">1.1.1.</span> <span class="toc-text">reference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pointer"><span class="toc-number">1.1.2.</span> <span class="toc-text">pointer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-const-qualifier"><span class="toc-number">1.2.</span> <span class="toc-text">2.4 const qualifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Dealing-with-types"><span class="toc-number">1.3.</span> <span class="toc-text">2.5 Dealing with types</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#type-aliases"><span class="toc-number">1.3.1.</span> <span class="toc-text">type aliases</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#the-auto-type-specifier"><span class="toc-number">1.3.2.</span> <span class="toc-text">the auto type specifier</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-strings-vectors-and-arrays"><span class="toc-number">2.</span> <span class="toc-text">Chapter 3. strings,vectors, and arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-namespace"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-strings"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 strings</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string初始化"><span class="toc-number">2.2.1.</span> <span class="toc-text">string初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string运算"><span class="toc-number">2.2.2.</span> <span class="toc-text">string运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-vectors"><span class="toc-number">2.3.</span> <span class="toc-text">3.3 vectors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector初始化"><span class="toc-number">2.3.1.</span> <span class="toc-text">vector初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-introducing-iterators"><span class="toc-number">2.4.</span> <span class="toc-text">3.4 introducing iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-arrays"><span class="toc-number">2.5.</span> <span class="toc-text">3.5 arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#识别复杂的类型符号"><span class="toc-number">2.5.1.</span> <span class="toc-text">识别复杂的类型符号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-6-Functions"><span class="toc-number">3.</span> <span class="toc-text">Chapter 6. Functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-7-Classes"><span class="toc-number">4.</span> <span class="toc-text">Chapter 7. Classes</span></a></li></ol></div></div><div class="post-content"><a id="more"></a>
<h2 id="Chapter-2-Variables-and-Basic-types"><a href="#Chapter-2-Variables-and-Basic-types" class="headerlink" title="Chapter 2. Variables and Basic types"></a>Chapter 2. Variables and Basic types</h2><h3 id="2-3-Compound-types"><a href="#2-3-Compound-types" class="headerlink" title="2.3 Compound types:"></a>2.3 Compound types:</h3><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p>reference是一个object的alis,别名。这句话怎么理解？我们首先必须定义一个对象，然后这个对象本身有一个名字，然后才能用reference给这个对象取一个别名，这个别名和本名都是同一个对象，用别名或本名都可以对这个对象操作。也就是说，reference本身不是个对象，因此就不存在reference的reference了，这点和指针本质的区别。</p>
<ul>
<li><p>为什么用别名呢？<br>这个主要是在调用函数的时候使用，我们都知道调用函数默认是pass-by-value,如果这个希望在函数中也操作同一个对象，我们之前知道用pointer,但pointer是底层的一种操作方式，灵活多变但很容易出错，这个时候就可以用reference了，函数的入口参数是一个reference就可以解决让函数操作同一个对象了。</p>
</li>
<li><p>reference和指针的不同是什么？<br>reference只是给已经存在的对象起了一个名字，因此reference和普通的对象一样，在同一个层次，而且一旦针对某个object取了名字，这个名字就不能给其他对象取了，也就是说reference不灵活，这个不灵活从另一个角度看就是reference使用更简单更安全。总结：reference在创建的时候就需要初始化，而且创建后就不能修改，一般用在函数传递时操作同一个对象。问题来了，reference和指针区别是啥？两者在使用的时候，都可以在函数调用时让函数操作同一个对象。我认为区别就是，reference由于不能修改指向的位置，因此是固定的，可以把reference看成const指针，所以，如果希望在调用函数时被指的对象能发生变化，那么妥妥就是指针了，如果没打算改变，就reference效果一样还不错</p>
</li>
</ul>
<h4 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h4><p>指针和reference最大不同是：指针是一个对象，有地址存指针。所以，指针就可以创建的时候不指向任何对象，即使指向某个对象还可以修改指向别的对象。</p>
<ul>
<li>指针和reference的关联<br>指针是对象，而reference不是对象，因此没有指向reference的指针，但反过来说：reference to　pointer就可以。</li>
</ul>
<h3 id="2-4-const-qualifier"><a href="#2-4-const-qualifier" class="headerlink" title="2.4 const qualifier"></a>2.4 const qualifier</h3><p>const就是某个变量的值不改变，因此，首先要有个变量，然后这个变量还需要有初值，这个时候在这条define的语句前加const关键字就可以了。例如：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">cost int bufsize</span>=512;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>const+extern<br>const的变量，默认情况是local to a file,也就是在一个file内可见，如果希望别的file也可见，可以在加extern 来标志：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//file_1.cc</span></div><div class="line"><span class="keyword">extern</span> cost <span class="keyword">int</span> bufsize=<span class="number">512</span>;<span class="comment">//定义</span></div><div class="line"><span class="comment">//file_1.h</span></div><div class="line"><span class="keyword">extern</span> cost <span class="keyword">int</span> bufsize;<span class="comment">//声明</span></div></pre></td></tr></table></figure>
</li>
<li><p>const+reference<br>c++麻烦就麻烦在，太多名词，而且名词之间相互搭配，还有很多exception.这里就遇到一个。我们之前说过，reference本身不是对象，不能单独存在，需要依附已经有的对象，但有例外：如果const+reference，reference就可以指向对象，literal, or a more general expression.也就是说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=i;<span class="comment">//ok：const reference to object</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2=<span class="number">42</span>;<span class="comment">//ok:const reference to literal</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3=r1*<span class="number">2</span>;<span class="comment">//const reference to expression</span></div><div class="line"><span class="keyword">int</span> &amp;r1=r*<span class="number">2</span>;<span class="comment">//error</span></div></pre></td></tr></table></figure>
<p>上面的做法可以这么理解：由于是const，也就是不能通过reference去修改，由于不能修改，那么变量可以，常量也一样了。const＋reference让问题变得简单，所以限制变少，这样理解就容易了！<br>另一个，const+reference只是说通过这个reference不能修改对象，但是一个对象可能有多个reference,通过non-const reference仍然可以修改原来对象。</p>
</li>
</ul>
<h3 id="2-5-Dealing-with-types"><a href="#2-5-Dealing-with-types" class="headerlink" title="2.5 Dealing with types"></a>2.5 Dealing with types</h3><p>随着程序变得复杂，类型也变得复杂。导致两个问题：</p>
<ul>
<li>类型名称太长，太长就导致意义不清晰，写起来也容易出错</li>
<li>不晓得一个结果应该是什么类型，这时候又需要回头去看代码细节，弄明白类型是什么，很头痛</li>
</ul>
<p>如何handle复杂的类型？</p>
<h4 id="type-aliases"><a href="#type-aliases" class="headerlink" title="type aliases"></a>type aliases</h4><p>传统的是用：typedef<br>c++11有新方法：using SI=Sales_item;这个更容易理解</p>
<ul>
<li>pointers+const+type aliases<br>用typedef遇到指针的话，有新的情况需要clarify:<br>例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</div><div class="line"><span class="keyword">const</span> pstring cstr=<span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr1=<span class="number">0</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>说明：cstr和cstr1不同。pstring是指针，所以const pstring表示cstr是一个const pointer;而后面一句中，const是修饰char,所以cstr1表示指向const char的指针。这个区别的原因是：用typedef得到的类型由于先bind成一个整体，在使用的时候这个整体再和其他的限定符来组合；而直接使用typedef中原来类型，则这些类型就不能有限组合了。继续思考，就是typedef相当于下面：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (<span class="built_in">char</span>*) <span class="built_in">cstr</span>=<span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>也就是说typedef优先级更高，相当于加括号，优先级高因此和其他的限定符就不是一个层次的了。c++虽然细节很多，但有意思！</p>
<h4 id="the-auto-type-specifier"><a href="#the-auto-type-specifier" class="headerlink" title="the auto type specifier"></a>the auto type specifier</h4><p>auto的使用，类型由编译器来自动匹配。(略)</p>
<h2 id="Chapter-3-strings-vectors-and-arrays"><a href="#Chapter-3-strings-vectors-and-arrays" class="headerlink" title="Chapter 3. strings,vectors, and arrays"></a>Chapter 3. strings,vectors, and arrays</h2><h3 id="3-1-namespace"><a href="#3-1-namespace" class="headerlink" title="3.1 namespace"></a>3.1 namespace</h3><p>用namespace可以解决名称的conflict.说透了，就是同一个代码，同一个名字，因为属于不同的namespace,就不同了，就不矛盾了，或者说不同namespace的变量和函数处于不同的世界或层次，虽然眼睛能看到的是放在一起，但由于属于不同namespace，就导致他们之间有看不见的鸿沟</p>
<h3 id="3-2-strings"><a href="#3-2-strings" class="headerlink" title="3.2 strings"></a>3.2 strings</h3><h4 id="string初始化"><a href="#string初始化" class="headerlink" title="string初始化"></a>string初始化</h4><p>-　有两种，一种是：copy initialization;一种是direct initialization.如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s5=<span class="string">"hiya"</span>; <span class="comment">//copy</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">"hiya"</span>)</span></span>;<span class="comment">//direct</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//direct</span></div></pre></td></tr></table></figure></p>
<p>有=就是copy初始化，因为编译器会先把等号右边的string literal变成一个string tmp,然后把这个tmp复制给新建的，一件事就变成了两道工序，慢还费空间。</p>
<h4 id="string运算"><a href="#string运算" class="headerlink" title="string运算"></a>string运算</h4><p>string加法：原则是做加法的两个对象必须有至少一个是string,不能两个string literal相加。<br>举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s4=s1+<span class="string">","</span>;//ok</div><div class="line"><span class="built_in">string</span> s4=<span class="string">"hello"</span>+<span class="string">","</span>;//<span class="built_in">error</span>.两个常量加不可以</div><div class="line"><span class="built_in">string</span> s4=s1+<span class="string">","</span>+<span class="string">"world"</span>;//ok.因为s1+<span class="string">","</span>返回一个<span class="built_in">string</span> tmp,tmp+<span class="string">"world"</span>，这就是级联的效果</div><div class="line"><span class="built_in">string</span> s4=<span class="string">"hello"</span>+<span class="string">","</span>+s2;//<span class="built_in">error</span>.<span class="string">"hello"</span>+<span class="string">","</span>不能够</div></pre></td></tr></table></figure></p>
<h3 id="3-3-vectors"><a href="#3-3-vectors" class="headerlink" title="3.3 vectors"></a>3.3 vectors</h3><p>vector是容器。</p>
<h4 id="vector初始化"><a href="#vector初始化" class="headerlink" title="vector初始化"></a>vector初始化</h4><p>两种方式，一种list initializer,一种element count.如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>)；<span class="comment">//element count:10个元素初值0.</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">10</span>&#125;；<span class="comment">//list initializer.一个元素10</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>,<span class="number">1</span>)；<span class="comment">//element count:10个元素初值1.</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">10</span>,<span class="number">1</span>&#125;；<span class="comment">//list initializer.两个元素10和1</span></div></pre></td></tr></table></figure></p>
<h3 id="3-4-introducing-iterators"><a href="#3-4-introducing-iterators" class="headerlink" title="3.4 introducing iterators"></a>3.4 introducing iterators</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> b=v.<span class="built_in">begin</span>(),e=v.<span class="built_in">end</span>();</div></pre></td></tr></table></figure>
<p>b指向v的第一个元素，e指向v的最后元素的下一个位置，也就是不是最后一个元素，这是一个很容易忽略的问题，自己写代码就犯过错，把end()误当成是v的最后一个位置。那为什么这么设置呢？如果不这么设置，而让.end()指向v的最后一个元素，那么当v只有一个元素时，v.begin()==v.end(),当没有元素的时候，就表示不了了，所以这么设置的目的，是为了方便表示空的情况,即：当v.begin()==v.end()，v为空。这么想，就容易理解了！</p>
<p>iterator的操作有==,!=,++,–等。注意没有定义大于或小于符号，因此就用不等号和遍历的方向就够了.</p>
<ul>
<li>iterator types<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</div><div class="line"><span class="built_in">string</span>::iterator it2;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>说明：const_iterator就是表示这个iterator是const,只能用来读，不能用来写，相当于const指针，也就是规定了权限。</p>
<ul>
<li>iterator arithmetic<br>对vector和string的iterator,支持一次移动n步，例如：<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">iter+n</span></div><div class="line"><span class="keyword">iter-n</span></div><div class="line"><span class="keyword">iter+=n</span></div><div class="line"><span class="keyword">iter-=n</span></div><div class="line"><span class="keyword">iter1-iter2</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>支持一次移动多个位置的原因，是因为vector和string是顺序container,也就是元素在内存中是连续的存放的，所以这么计算对编译器没难度，都是o(1)的操作，而其他复杂数据结构的iterator就不支持这样的操作。由于是顺序的container,所以除了支持相等不等，还支持大于小于这些比较操作，使用起来更方便更灵活，不过其他非顺序container就没这个运算了。</p>
<h3 id="3-5-arrays"><a href="#3-5-arrays" class="headerlink" title="3.5 arrays"></a>3.5 arrays</h3><p>array相对vector，长度是固定的，在编译的时候就确定了，如果应用长度是事先就固定的已知的，就可以用array，因为array的速度快。</p>
<h4 id="识别复杂的类型符号"><a href="#识别复杂的类型符号" class="headerlink" title="识别复杂的类型符号"></a>识别复杂的类型符号</h4><p>例如，<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> *ptrs[<span class="number">10</span>];//从右往左结合：ptrs是放<span class="number">10</span>个指针的<span class="built_in">array</span></div><div class="line"><span class="built_in">int</span> (*<span class="type">Parray</span>)[<span class="number">10</span>]=&amp;arr;//先看括号内的，括号内的一个指针，括号外用从右往左结合，<span class="number">10</span>个<span class="built_in">int</span>的<span class="built_in">array</span>,所以就是一直指针指向<span class="number">10</span>个数的<span class="built_in">array</span></div><div class="line"><span class="built_in">int</span> (&amp;<span class="type">Parray</span>)[<span class="number">10</span>]=&amp;arr;//先看括号内，一个reference,所以，<span class="type">Parray</span>是<span class="number">10</span>个数的<span class="built_in">array</span>的reference</div><div class="line"><span class="built_in">int</span> *(&amp;rarray)[<span class="number">10</span>]=ptrs;//先看括号，rarray是reference,然后看外面，<span class="number">10</span>个指针的数列，所以整个就是rarray是<span class="number">10</span>个指针的数列的reference.</div></pre></td></tr></table></figure></p>
<h2 id="Chapter-6-Functions"><a href="#Chapter-6-Functions" class="headerlink" title="Chapter 6. Functions"></a>Chapter 6. Functions</h2><h2 id="Chapter-7-Classes"><a href="#Chapter-7-Classes" class="headerlink" title="Chapter 7. Classes"></a>Chapter 7. Classes</h2><p>这章讲类的概念。所谓类，就是c++和c的区别之一：data abstraction和encapsulation思想的具体实现。</p>
<ul>
<li><p>什么是data abstraction?<br>data abstraction:一种设计方法，依赖接口和实现的分离。简单说，接口就是功能，这个类对外宣称可以实现的具体功能是什么，这个叫接口；实现则是功能的具体实现方法和细节，同一个接口或功能，可以采用不同的实现细节。接口或功能是对类外面的使用者而言，或者说是从外面看到的类的样子，实现细节则是被包裹在类以内，从外面是无法接触无法看到无法感觉得到的，因此可以认为实现细节是从类的内部看到的。因此，还可以说接口是类的外表，实现则是类的内涵。前面说了这么多功能和细节分离的理念。那什么是data abstraction? 书上也没说清楚，论坛帖子也没说明白。<br>我自己的理解是，(以后有新的理解可以继续更新),abstraction就是站在类或对象之外看到的对象，由于对象是encapsulation的，所以能看到的只有接口或功能。</p>
</li>
<li><p>什么是encapsulation?<br>封装和data abstraction相对的概念，如何相对？data abstraction是站在类外面看到的，而封装则是站在类里面看到的组织结构，即：类的结构是就接口或功能以及这些功能的实现，接口或功能是对外的形象，功能的实现则是类的内涵。<br>写了一个答案，发现没地方放，就放这里：</p>
<blockquote>
<p>I would like to conclude the difference into one sentence for easy comprehension. Abstraction and encapsulation are different sayings from two opposite views. Abstraction is what we see when  standing outside of the class/object, while encapsulation is what we see when standing inside the class/object.</p>
</blockquote>
</li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://ptbws.github.io/2017/03/04/看书cpp primer/" data-id="cizxx8l2r0005ojeodij4o40q" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2017/03/05/我不是潘金莲电影/" class="pre">李雪莲之死</a><a href="/2017/03/03/cpp复习/" class="next">c++复习</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://ptbws.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/找工作/">找工作</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/c-，找工作/" style="font-size: 15px;">c++，找工作</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/基础很重要/" style="font-size: 15px;">基础很重要</a> <a href="/tags/不同的视角/" style="font-size: 15px;">不同的视角</a> <a href="/tags/c语言/" style="font-size: 15px;">c语言</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/浪漫/" style="font-size: 15px;">浪漫</a> <a href="/tags/现实/" style="font-size: 15px;">现实</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/05/我不是潘金莲电影/">李雪莲之死</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/04/看书cpp primer/">看书cpp primer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/03/cpp复习/">c++复习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/c语言复习/">c语言复习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/面试/">面试总结-2/21/2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://hahack.com/" title="哈嘿！" target="_blank">哈嘿！</a><ul></ul><a href="https://dlyang.me/" title="LanternD" target="_blank">LanternD</a><ul></ul><a href="https://login926.top/" title="Raintone" target="_blank">Raintone</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">ptbws.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>