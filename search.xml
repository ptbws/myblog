<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[c语言复习]]></title>
      <url>https://ptbws.github.io/2017/02/22/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="面试中遇到的问题："><a href="#面试中遇到的问题：" class="headerlink" title="面试中遇到的问题："></a>面试中遇到的问题：</h2><h3 id="malloc-和calloc-的区别是什么？"><a href="#malloc-和calloc-的区别是什么？" class="headerlink" title="malloc()和calloc()的区别是什么？"></a>malloc()和calloc()的区别是什么？</h3><ul>
<li><p>刚问了cplusplus.com.总结一下区别: void* malloc(size_t size):前面的void*看起来不眼熟，但只要把void换成int,就知道怎么回事了。int*表示指向int型数据的指针 ，也就是地址；同理，void*则表示指向一个地址，但是这个数据的类型可以是任何数据类型。malloc(size_t size)函数入口参数是分配的空间大小，确切说是分配的byte数量，因此这个空间存储什么数据类型必须明确告诉malloc,例如：<a id="more"></a></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*) <span class="built_in">malloc</span> (i);</div><div class="line"><span class="comment">//i表示byte数量</span></div></pre></td></tr></table></figure>
<p> 在上面malloc()前面的(char*)，如何理解？参考了网络文章，发现是强制类型转换，具体说，就是把malloc返回的void*强制转换成指向char的指针，也就是说void*可以被强制类型转换成其他类型。</p>
</li>
<li><p>类似的，calloc()语法是：void* calloc (size_t num, size_t size); 和malloc不同的是，calloc有两个入口参数，一个表示分配空间存的元素的个数，注意不是byte的个数，这两个是有区别，另一个表示存的元素占用的byte数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* pData = (<span class="keyword">int</span>*) <span class="built_in">calloc</span> (i,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"><span class="comment">//(int*)强制类型转换</span></div></pre></td></tr></table></figure>
<p>cplusplus就是写得透彻。这<strong>两者的区别</strong>一句话就说明白：malloc以字母m开头，表示的是从memory角度来看这个分配，memory是不分别数据类型的，一律用byte的数量表示memory分配大小，所以malloc一个入口函数就够了，毕竟底层器件能看到的世界和上层不同；calloc：就是contiguous allocation,为什么叫连续分配？因为他是从c语言的角度，而不是从存储器角度，来分配的。从c语言，如果我现在要存100个int，和存100个char，相同的是都要分配100个空间，不同的是每个空间大小不一样。所以，连续分配是指连续分配n个size相同的空间，每个空间的size需要单独指定。</p>
</li>
<li>两种区别一句话表示为：malloc is to allocate memory block; calloc is to allocate and zero-initialize array.</li>
<li>由于是动态内存管理，分配使用后，必须手动释放，所有上面两种分配都需要free(指针)</li>
</ul>
<h3 id="short-int-long长度？由于不同系统对同一个数据类型，比如long，定义是不一样，-如何保证代码的可移植性呢？"><a href="#short-int-long长度？由于不同系统对同一个数据类型，比如long，定义是不一样，-如何保证代码的可移植性呢？" class="headerlink" title="short,int,long长度？由于不同系统对同一个数据类型，比如long，定义是不一样， 如何保证代码的可移植性呢？"></a>short,int,long长度？由于不同系统对同一个数据类型，比如long，定义是不一样， 如何保证代码的可移植性呢？</h3><ul>
<li>在32位系统中，short表示2 byte, int 4 byte, long 8byte.为了移植，用typedef 来自己重命名类型,例如： typedef int int16，把int命名成int16,如果移植到32位系统，那么只需要修改typedef的定义即可，不用全部替换，例如：typedef short int16</li>
</ul>
<h3 id="include-和include-“header-h”区别"><a href="#include-和include-“header-h”区别" class="headerlink" title="include 和include “header.h”区别"></a>include <header.h>和include “header.h”区别</header.h></h3><ul>
<li>&lt;&gt;表示编译器首先去标准库里搜索这个头文件；“”表示是用户自定义的头文件，因此去当前目录查找</li>
</ul>
<h2 id="网络搜集的问题-amp-看书C-Promgramming-A-modern-approach"><a href="#网络搜集的问题-amp-看书C-Promgramming-A-modern-approach" class="headerlink" title="网络搜集的问题&amp;看书C Promgramming: A modern approach"></a>网络搜集的问题&amp;看书C Promgramming: A modern approach</h2><h3 id="typedef和-define区别？"><a href="#typedef和-define区别？" class="headerlink" title="typedef和#define区别？"></a>typedef和#define区别？</h3><ul>
<li>总的说来，typedef比＃define更powerful.define就是简单的替换，在preprocessing时完成；typedef是在编译的时候完成，和variable一样，有作用域和生存周期，而且typedef末尾有分号，表示是一句代码，而#define末尾没有符号。上面的讨论说明一个啥问题呢？预编译器的功能和编译器比起来，功能简单，能做的事有限。这么说就解释了typedef强大，而#define就弱，弱是因为preprocessor弱所导致！</li>
<li>typedef只能给一个类型重命名；#define还可以定义常量。</li>
<li><p>两者的区别，下面的例子很说明问题，参考了大神解释，<a href="http://stackoverflow.com/questions/1666353/are-typedef-and-define-the-same-in-c" target="_blank" rel="external">http://stackoverflow.com/questions/1666353/are-typedef-and-define-the-same-in-c</a>　一句话，typedef定义指针啊，复杂类型啊，很好用；而define就弱很多</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* int_p1;</div><div class="line">int_p1 a, b, c;  <span class="comment">// a, b, and c are all int pointers.</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> int_p2 int*</span></div><div class="line">int_p2 a, b, c;  <span class="comment">// only the first is a pointer!</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> a10[<span class="number">10</span>];</div><div class="line">a10 a, b, c; <span class="comment">// create three 10-int arrays</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func_p)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line">func_p fp <span class="comment">// func_p is a pointer to a function that</span></div><div class="line">          <span class="comment">// takes an int and returns an int</span></div></pre></td></tr></table></figure>
</li>
<li><p>define是宏定义，由于有#在前，因此和#include一样，是预编译指令，所谓预编译，是在正式的compile之前需要做的事，做什么呢？例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INCHES_PER_POUND 166</span></div></pre></td></tr></table></figure>
<p>就是简单的数据替换，在代码中遇到INCHES_PER_POUND,就替换成166。还可以做什么呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RECIPROCAL_OF_PI (1.0f/3.14159f)</span></div></pre></td></tr></table></figure>
<p>上面的例子在替换之前，还需要做简单的运算，但这里值得注意的是，需要把运算表达式用parentheses enclosed，否则不运算，而直接用后面的表达式替换。另外，用大写也是个约定俗成的不是规定的规定。</p>
</li>
</ul>
<h3 id="用int如何保存-2-31"><a href="#用int如何保存-2-31" class="headerlink" title="用int如何保存$2^{31}$?"></a>用int如何保存$2^{31}$?</h3><ul>
<li>int的范围是$-2^{31}$到$2^{31}-1$，因为要表示0嘛。所以正数的表示范围比负数范围的小1，如果非要表示$2^{31}$，要么用long，要么用unsigned int。</li>
</ul>
<h3 id="运算符的优先级顺序是怎样的？"><a href="#运算符的优先级顺序是怎样的？" class="headerlink" title="运算符的优先级顺序是怎样的？"></a>运算符的优先级顺序是怎样的？</h3><ul>
<li>最先计算的是单目运算符号，例如！，+，-</li>
<li>然后是*,/,%</li>
</ul>
<h3 id="if-和switch区别："><a href="#if-和switch区别：" class="headerlink" title="if 和switch区别："></a>if 和switch区别：</h3><ul>
<li>switch：判断的对象如果是一个变量，且是int或char。使用时，每个分支执行完，需要break;语句,否则会顺序执行后面的语句，所以说c语言确实是比较底层的语言，和机器打交道的，比较low</li>
<li>if:使用无限制</li>
</ul>
<h3 id="stack-vs-heap"><a href="#stack-vs-heap" class="headerlink" title="stack vs heap?"></a>stack vs heap?</h3><ul>
<li>stack是静态内存分配，是自动的分配,在编译之前就知道需要分配多大空间，就用stack,使用完成后，自动释放，用来存local的变量；heap是动态内存分配，在run-time的时候才知道需要多大空间，而且用指针访问，所以慢，由于是动态的，所以不知道会使用多久，因此需要用户explicit deallocate,<br>－两者共同的地方是都存在ram内。</li>
</ul>
<h3 id="virtural-memory怎么回事？"><a href="#virtural-memory怎么回事？" class="headerlink" title="virtural memory怎么回事？"></a>virtural memory怎么回事？</h3><ul>
<li>虚存并不是c语言的知识，是操作系统的功能。虚存和实际的ram是一个相对的概念，虚存是建立在实际ram之上，但又不等于ram的一套方法。由于c语言需要分配多大内存空间，例如动态内存分配的时候，不是直接和物理ram打交道，而是和操作系统打交道，告诉操作系统这个程序需要多大的内存，操作系统就去准备，正常情况下如果物理内存空间大于需要的空间，就不需要虚存的概念。虚存的提出是解决内存不足的情况。当物理内存只有50MB,而需要120MB,现在操作系统就需要用虚存的方法来解决这个问题，首先发现内存不够，因此就利用hard disk来帮忙，把ram上暂时不适用的内容和hard disk上需要用的内容swap,从c语言的角度看，好像确实有120MB空间存在一样，殊不知这是操作系统屏蔽了如何实现120MB的细节，这个操作系统凑齐120MB的方法就是虚存的概念。</li>
<li>虚存的实现是靠virtual memory manager.在硬盘上划定一块区间，根据需要不断的swap内存和硬盘的内容。</li>
<li>用虚存的原因，上面已经提到是因为内存不够，硬盘来凑。这个内存不够，除了指一个程序需要的内存超过了可用的空间，还包括多个程序同时multi-tasking时所需要的内存操作了可用的空间。</li>
<li>由于虚存要不停的swap，而且访问硬盘，所以虚存的概念是尽力满足需求，但是操作的速度就不保证了。和网络传送的best effort的思想是一样的，网络传送文件会尽力传送，但是如果有网络拥塞，那么就选择一条远的路传，虽然传成功了，但时延却很大。</li>
</ul>
<h3 id="c程序编译的过程？"><a href="#c程序编译的过程？" class="headerlink" title="c程序编译的过程？"></a>c程序编译的过程？</h3><ul>
<li>preprocessing: 预处理。主要是处理#开头的语句，例如：库文件包含，宏定义，通过这些语句修改添加信息进入source code</li>
<li>compiling: 编译。修改后的代码进入编译，编译就是把代码翻译成机器指令</li>
<li>linking: 链接。就是把机器代码转换成可执行代码。</li>
</ul>
<h3 id="printf-时输出格式说明"><a href="#printf-时输出格式说明" class="headerlink" title="printf()时输出格式说明"></a>printf()时输出格式说明</h3><ul>
<li>％m.pX:例如：%10.2f。</li>
<li>m表示minimum field width,就是说输出的字符的数量最小是m个，如果本身这个变量包含的字符数少于m，那么就填空格；如果多于m，有多少输出多少。</li>
<li>p表示精度。对float而言，是小数点后的字符数，如果10.23f让输出的精度为3，那么也就是说需要3位小数位，则填0;对int而言，则表示整数位的个数，例如：23d,要输出精度为3,则输出为023,在前面添０</li>
<li><p>X表示类型，d,f,c,e,g.<br>例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">40</span>;</div><div class="line">float <span class="keyword">x</span>=<span class="number">839.21</span>f;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"|%d|%5d|%-5d|%5.3d|\n"</span>,i,i,i,i);</div><div class="line"><span class="keyword">printf</span>(<span class="string">"|%10.3f|\n"</span>,<span class="keyword">x</span>);</div></pre></td></tr></table></figure>
<p>输出为：<br>|40|   40|40   |  040|<br>|   839.210|<br>需要说明的是：由于输出默认是右对齐，所以在％后面添加-表示左对齐；打印float输出是，m=10，表示输出最小的charactor数，其中包括数字本身，包括添加的0，包括添加的空格，还要包括小数点！</p>
</li>
</ul>
<h3 id="Operator-precedence-and-associativity"><a href="#Operator-precedence-and-associativity" class="headerlink" title="Operator precedence and associativity"></a>Operator precedence and associativity</h3><ul>
<li>运算符优先级和结合顺序：unary Operator(+,-,!)高于binary operator;结合顺序，有从左往右的，例如：+-*/,还又从右往左的,例如:单目运算符，-+i,就是-(+i)</li>
<li>截了个图，你看所有的赋值符号，优先级最低；然后postfix(i++或i–)优先级最高，其次是prefix(++i和--i)<br><img src="http://i.imgur.com/KIY4ukg.png" alt=""></li>
<li>\==，equality operator:优先级低于关系运算符，例如：i&lt;j\==j&lt;k,相当于(i&lt;j)\==j&lt;k,即：先比较左右不等符号，然后在evaluate相等符号。</li>
<li>Logical operator:　！(单目运算符)，&amp;&amp;,||。这里说明几点：<blockquote>
<p>||和&amp;&amp; perform “short circuit” evaluation.也就是说，由于运算结果就只有0,1两种，因此运算过程中只要等于1/0就再也不可能等于0/1的时候，就不用把后面的都给evaluate了，节省时间。例如：a||b,如果a等于1,那么就不用判断b;同理，a&amp;&amp;b,如果a等于0，那么也不用判断b。这就是“short circuit”。这个做法还是有点意思！</p>
<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h3><ul>
<li>书上提到了一个“<strong>dangling case</strong>”:dangling就是悬挂，悬吊的意思。这里用来说明if-else嵌套时配对的问题。例如：<img src="http://i.imgur.com/amo6nFU.png" alt="Drawing (87)"><br>上图，看结构，else是打算和第一个if配合，但是书写的结构和c语言编译的结果不是一回事，看下面，<br><img src="http://i.imgur.com/xvD5FJD.png" alt=""><br>c语言是把else和前面距离最近，且没有配对的if配对在一起。因此，为了防止这个理解错误，即：dangling case,需要用braces把if－else的配对情况表示清楚，不能含混.如下图：<br><img src="http://i.imgur.com/U4W8ebm.png" alt=""></li>
<li>通过这一点，确实应该有时间学一下编译原理，知道编译器如何识别代码的，可以减少很多书写的错误。比如这个if-else，这个配对的过程让我想起括号配对的问题，例如:()(()),你看左括号就是if,右括号就是else.所以，算法的东西也用上了，为了判断是否配对，用一个stack就可以实现。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><ul>
<li>能有switch的地方就能用if,switch就是个特例。如下图：<br><img src="http://i.imgur.com/X96mY8Y.png" alt=""><br>需要说明的是，<blockquote>
<ul>
<li>switch()入口的表达式的结果必须是int或char,char本质就是int，所以可以简化说结果必须是int；</li>
<li>case后面的必须是常数表达式，4+2可以，但4+i不可以</li>
<li>每个case后面的语句是顺序执行，而且必须用break结束，否则会一直顺序执行下去，这就是switch设计得不好的地方了，但为什么这么设计？没说！</li>
<li>当然trick的地方是，有些程序设计员利用switch一旦开始执行就停不下来的特点，故意在某些case后不用break语句，专门让其连续执行，我想说，这个思路可取的地方就是认清了switch麻烦的地方不是去严格执行规定，避免出错，而是大胆挑战这条规矩，也不是挑战，就是换个思路去看所谓的限制，转不利为有利。除开这点不说，说执行效率，我觉得还是比较慢，如下图。你看，当grade等于4,则需要分别执行case 4,3,2,1四条语句，虽然每个语句为空，但是时间就慢了。不过这个敢于转不利为有利的胆识，值得赞叹！<br><img src="http://i.imgur.com/OaUNXYg.png" alt=""></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="Loops-略"><a href="#Loops-略" class="headerlink" title="Loops(略)"></a>Loops(略)</h3><h3 id="Basic-types"><a href="#Basic-types" class="headerlink" title="Basic types"></a>Basic types</h3><h4 id="int讲解："><a href="#int讲解：" class="headerlink" title="int讲解："></a>int讲解：</h4><ul>
<li>如下图。上次面试就出这个题了，问32-bit的机器表示short,int,long的byte数，这就是答案啊。short无疑问2byte，int 4byte,long在32位机器中居然也是4byte.这就是基础，得重视！还要注意的是，unsigned int和int unsigned顺序无关紧要，都表示无符号整型。<br><img src="http://i.imgur.com/9bALVPz.png" alt=""><h4 id="float型：三种。"><a href="#float型：三种。" class="headerlink" title="float型：三种。"></a>float型：三种。</h4></li>
<li>float,double, long doule。float就是单精度，32bit,double用64bit表示。都是用科学计数法表示：符号＋指数＋小数。float中，8bit表示指数，23bit表示小数。<h4 id="自动类型转换-不同数据类型转换。"><a href="#自动类型转换-不同数据类型转换。" class="headerlink" title="自动类型转换: 不同数据类型转换。"></a>自动类型转换: 不同数据类型转换。</h4></li>
<li>为了保证不丢失信息，通常是允许从简单的类型转换转换成复杂类型，比如从int到float，或者是从短类型转到长的类型，比如从int到long。为啥呢？这样做不丢信息，而反过来，就要丢信息，如果丢信息，就有可能把重要信息丢失导致数据转换后四不像。<blockquote>
<ul>
<li>unsigned int和int一起参与运算，会把(signed)int转换成unsigned然后参与运算，结果也是unsigned.因此，最好不要这么来运算，结果往往和预想的不同。这种情况，虽然不会报错，但是会产生warning，因此还是要看warning。<h4 id="casting"><a href="#casting" class="headerlink" title="casting:"></a>casting:</h4></li>
</ul>
</blockquote>
</li>
<li>前面讨论的是自动转换，这里cast就是强制转换，手动档。想起前面的(char*)malloc(m),或者(int*)calloc(m,sizeof(int)),(char*)或(int*)就是强制类型转换，括号里的类型是转换后的类型，那转换前的类型呢？是void*,这是指针，但指向类型没确定。看得出，这个强制类型转换是增加信息的，和自动的不一样。下面有几个cast的用途：<blockquote>
<ul>
<li>除法的时候，希望int相除能保留小数，那么可以这样：float res=(float)i/j;如果直接float res=i/j;则是先按照整数计算，这个时候小数部分已经丢失，然后把这个计算结果自动转换成float；而前一种方法，把参与运算的一个数先转为float,那么编译器看到一个是float,一个是int,就会自动把int转换成float，然后结果就可以保留小数了。</li>
<li>防止overflow,例如：long i=j*j; j是int很大的值，那么相乘后就会溢出，也就是说还没有转换成long之前就overflow了。这个时候就可以用cast了，如：long i=(long)j*j;这么写就是先把其中一个转换成long,然后编译器看到参与运算的一个是long,一个是int,则自动把int转换成long,最后就是long和long的运算，结果自然就是long.　也就是说，运算数，而不是结果转换为长度较长的类型是最安全的。<h4 id="type-definition"><a href="#type-definition" class="headerlink" title="type definition:"></a>type definition:</h4></li>
</ul>
</blockquote>
</li>
<li>typedef int Dollars；这是定义了新类型Dollars,但这个类型本质还是int,或者说Dollars是int的别名synonym.既然这样，那为什么还需要重新取名字呢？有几个好处和用途：<blockquote>
<ul>
<li>int和Dollars从机器角度看都是4byte的数据而已；但从程序员角度看，就差别大了，Dollars除了告诉程序员这个是int,还包含了这个是表示钱的变量，也就是描述问题更加贴近对象，而不是机器。从机器角度换成了问题角度！</li>
<li>方便修改类型，如果在代码后期，发现Dollars数量太大，不能用int表示，需要改成long,我们只需要改成typedef long Dollars；即可。操作起来快速，不用一个一个查找替换，即使你愿意查找替换，而且声称自己很仔细，还是可能因为某一个没有修改完全导致错误。</li>
<li>移植方便。如果在32-bit系统中可以用int就能工作，但是到16-bit系统，则发现要用long才可以，那么不用一个一个修改，直接修改typedef即可！</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="Arrays数列"><a href="#Arrays数列" class="headerlink" title="Arrays数列"></a>Arrays数列</h3><h4 id="const用法"><a href="#const用法" class="headerlink" title="const用法:"></a>const用法:</h4><ul>
<li>书上有个例子如下，在数据类型前面加const的左右是让compiler检查这个数组是否被修改，如果被修改，就报错。也就是说const是给编译器看的，当然也是给程序员看的，程序员一看到这个，就知道不能修改，修改了也没用，编译器不答应！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> hex_chars[]=&#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>...&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><h4 id="function-declarations-函数声明"><a href="#function-declarations-函数声明" class="headerlink" title="function declarations:函数声明"></a>function declarations:函数声明</h4><ul>
<li>如果函数的定义在使用之前，编译器检测到使用之前已经发现这个函数的定义，所以能正确找到这个函数的入口地址；如果函数的定义在使用之后，那么编译器发现需要使用函数的时候，不知道去哪儿找这个函数的入口地址，因为编译是从前往后编译的。为了将就编译器这个特点，也为了程序的设计灵活，如果程序的定义在使用之后，则需要在程序使用之前做一次声明，告诉编译器，我在后面定义了这个函数，不要给我报错，你自己去找。再次说明，学点编译原理有些必要！<blockquote>
<ul>
<li>函数声明就是告诉编译器这个函数入口参数个数，类型，返回值类型等信息，方便编译器进行检查。</li>
<li>函数声明语法上就是函数定义的第一句加上末尾分号。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="array-arguments"><a href="#array-arguments" class="headerlink" title="array arguments:"></a>array arguments:</h4><ul>
<li><p>array作为函数入口参数。array和单个数据不同的地方是，除了类型，还有长度这个参数。也就是说，要描述array继续要类型，还需要长度，所以在c语言里，如果用array做入口参数，需要传递类型，还要单独传递长度，否则函数是不知道这个array的长度。这个后面会解释。举例：</p>
 <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> sum_array(<span class="built_in">int</span> a[],<span class="built_in">int</span> n)<span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>注意上面的例子不能写成下面这样，</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> sum_array(<span class="built_in">int</span> a[n],<span class="built_in">int</span> n)<span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>原因还是编译器设计的问题：当编译器从左往右读到a[n],发现不认识n,即使n就在后面还是不认识，所以就急忙报错。这说明啥？说明c语言编译器没有结合上下文的能耐，最多就是结合上文。有了这个背景知识，那我们可以写成下面的样子，先告诉编译器n的存在，再告诉他a[n]，这么一来它就不出错：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> sum_array(<span class="built_in">int</span> n,<span class="built_in">int</span> a[n])<span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>用array做参数还有一个有趣的地方，就是可以在子函数中直接修改array的内容，不像传递一个值的时候，是pass-by-value。这一点也是需要后面解释的，这个也是编译器的操作有关。学了这么多年，好多奇怪的、不解释的语法和特点，都是设计编译器这帮人在后面搞鬼，搞清楚这点，以后遇到不理解的方法，都可以想想是不是编译器非要这么干不可，一般情况下，编译器设计和程序设计应该独立，但越是底层的语言，这两者就不可能完全独立，你不懂编译器的知识，不知道设计编译器这帮人考虑问题的方式，很多语法现象理解起来就困难，所以为了学底层的语言，编译器的知识还是要的。我估计写编译器这帮人也不得不懂一些底层语言的特点，这么一想也就平衡了，因为都是底层人员嘛。如果只是单方面要求写程序的人理解学习编译器，而他们一点程序设计的知识也不需要学的话，这就不公平了！</p>
</li>
<li><p>现在说说二维array如何传递到函数。例如：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define LEN 10</span></div><div class="line"><span class="built_in">int</span> sum_two_dimensional_array(<span class="built_in">int</span> a[][<span class="type">LEN</span>],<span class="built_in">int</span> n)<span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>看到和一维array的区别了吗？一维的长度是单独作为参数传递，有灵活性，而二维的就只有行数目可以传递，列数目必须在array的表示中明确表示出来，灵活性差一些，书上说可以通过array of pointer来解决这个问题。这个例子还看出，行数量可以省略，而列数量必须明确写出来！</p>
</li>
</ul>
<h3 id="Program-organization-程序架构"><a href="#Program-organization-程序架构" class="headerlink" title="Program organization:程序架构"></a>Program organization:程序架构</h3><p>前9章都是在讨论一个函数的设计会出现什么问题，主要包括：</p>
<blockquote>
<ul>
<li>单个数据类型的表示</li>
<li>同种数据间以及不同类型间的关系：相互运算，就涉及运算优先级和结合顺序，类型转换就涉及自动和强制.</li>
<li>各种语句（选择语句if-else和switch、循环语句while(),do-while和for、）</li>
<li>如果需处理多个同类型的数据，引入array的概念和方法来处理，提高效率；</li>
<li>函数如何调用，声明，参数如何传递，如果入口参数有array如何处理等。<br>你看，这个讨论顺序就是从简单的到复杂的，从一点到线，再到面，从方法论来说就是bottom-up的方法。现在的问题，我们站在一个函数的层次，看到什么呢？讲看到其他很多函数，这么函数如何interact尤其是有关联的时候，当然没有关联我们就没有必要讨论了，这里讨论的意义就是基于这些函数相互有关系。我们去explore这层关系，看编译器如何设计。<h4 id="Local-variables"><a href="#Local-variables" class="headerlink" title="Local variables"></a>Local variables</h4></li>
<li>每个函数体内的变量就是local，因此有automatic storage duration和block scope. 先说啥叫automatic storage duration?　这是说这个变量的生命长度，函数执行的时候分配空间，函数执行完毕，空间就回收了，这个变量就不存在了；再说block scope:这是说变量的存在空间只在这个函数的block内，严格的说是从定义开始到函数结束或block statements结束。这和上面的时间相对应，本来一切问题都是时空的问题，程序设计稍微有点哲学的味道。</li>
<li>Static Local variables: 和local的区别就是生命长度不在是automatic的，而是static的。所谓static storage duration就是编译器给这样的变量分配了一个永久的存储位置，让这个变量一直有效直到整个program结束。static名字取得很好，变量空间一旦分配就没打算用完就收回，因此这个空间一定和automatic storage的存储空间不一样，事实上，static存在heap上，和dynamic的内存分配放在一个区块，而automatic则是放在stack。这里也就是说编译器设计还是合理的，有些变量就是需要长期存在的，值得称赞！但需要注意的是，虽然存在时间长了，但是从这个变量往外看还是只能看到这个函数的边界，不能看到别的，因为它是local的嘛。因此，这样的变量适合用来多次调用同一个函数，不断修改里面的变量，例如：可以设置一个变量来统计函数调用的次数，那么就可以新建一个static local variable来统计。因此，使用这样的变量的物理意义，是对一个信息的计算不但依赖这一次的输入，还依赖以前的输入，因此可以认为是一个markov过程。你看，把数学的东西引入，问题看得更明白，也就容易appreciate这个语言设计的完备性！</li>
</ul>
</blockquote>
<h4 id="External-variables"><a href="#External-variables" class="headerlink" title="External variables"></a>External variables</h4><ul>
<li>external是相对于local而言的，由于local的变量总是属于某一个block，那么external则不属于任何block，任何函数，因此也叫global。external变量physically不属于任何函数，但是functionally则是属于任何函数。怎么讲？由于不偏向任何函数，所以每个函数都可以公平的使用他。这里就有点哲学意味，什么都拥有和什么都没有有时候是一回事。理解了这一点，就容易理解它的生命长度和生存空间了：<blockquote>
<ul>
<li>static storage duration:因为不属于任何函数，所以和任何函数结束与否没有关系，只和整个program结束有关系</li>
<li>file scope:还是上面的原因，不属于任何函数，因此就属于所有函数。能看到所有函数！</li>
</ul>
</blockquote>
</li>
<li>说了external的好处:可以在多个函数间传递大量的数据。再说external的不足：<blockquote>
<ul>
<li>由于谁都可以访问，谁都可以修改，如果在一个地方修改，在其他di</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 找工作 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试总结-2/21/2017]]></title>
      <url>https://ptbws.github.io/2017/02/22/%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>今天面试，面试前让看了一本gps书，看得很仔细的那种，自己还写了17页的pdf读书笔记，把书上的方法几乎都搞清楚了，就信心满满的去了，去了发现要现场做题，给了一页纸，就让作答，一看发现有一半不是书上的题，还有两个很开放的题，突然觉得这几天书白看了，自己看这么仔细，去了发现考的书上的知识都是很基本的，完全没必要看这么仔细。</p>
<p>当然看书也不亏，无意发现自己还可以喜欢看技术书，更发现一边看书一边写下自己的理解是一件很愉快的事。把一本厚厚的书按照自己的语言和习惯重新“写”一遍，这本书就不简单是原来那本书了，还加入了我自己读的时候的理解。无论理解的有没有到位，但这个记录过程就把自己读书的那时那刻的所思所想、肤浅的高深的都给摆在纸上，不藏着掖着，真实的面对看见自己在某一个时刻的思维的形状。</p>
<p>这儿记录一下印象深刻的问题：</p>
<blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Time_to_first_fix" target="_blank" rel="external">TTFF</a>: time to first fix. 这个书上没有，但干这个的人都知道，这就没办法，自己专业也不是这个。一查询，也不是啥高深的，就是gps第一次定位的时间，根据场景不同，分为cold start, warm start, hot start。</li>
<li>所谓cold start:就是卫星完全没有任何prior information. 需要一个一个的去捕获所有卫星，但捕获的时候，不是brute force.而是一旦捕获到一颗，就根据这颗卫星的信息，可知附近的卫星的位置，可以把这个信息用来帮助加快捕获其他卫星，而不用真正的全盲捕！这个思路也没什么高级的，但却是cold start最理想的方式，只有通过思考细节才能想到这个方法，也就是一颗卫星一颗卫星的来看，站在cold start的角度想。</li>
<li>warm start: 有prior data,例如：100km范围以内，20s时间以内等<ul>
<li>hot start： 就是当前的信息更清楚，比如:知道目前的位置坐标，目前的时间。</li>
</ul>
</li>
</ul>
</blockquote>
<p>另外还考了c语言的一些基础。发现自己好久不用不看c，很多基本问题都似是而非。看来，面试的时候，基础还是很重要，不能给别人感觉自己基础不扎实的感觉啊，因此，最近把c看了，然后把c++书再看看，尤其是自己不熟悉的章节，比如：继承。</p>
<p>另外一点，自己看面试，以为需要花很多时间把一些关键的问题搞得很透彻，而对一些不重要的问题很不上心，因为这些细枝末节很无趣没有挑战，而面试官却不这么看，他们没耐心去考察你是否透彻，他们主要关心你基础如何，能不能马上干活。所以，一个问题，涉及两个对象，两个对象对同一个问题理解就不一样。不一样不是因为两者看到的问题是两个问题。恰恰相反，两者看到的正是一个问题，只不过是一个问题的两个方面，每个人都习惯的从自己的立场去看这个问题，觉得理所当然。由于面试官是强势的一方，从而从面试官角度思考就显得重要了。以后，我应该做的是换个角度来看同一个问题，问题没变，是我调整了看他的角度，只是需要调整角度，问题就容易得到解决了。你看，观察多么重要！只要观察认可问题所在，而解决问题的方法就自然显露出来了！</p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 基础很重要 </tag>
            
            <tag> 不同的视角 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
