<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[李雪莲之死]]></title>
      <url>https://ptbws.github.io/2017/03/05/%E6%88%91%E4%B8%8D%E6%98%AF%E6%BD%98%E9%87%91%E8%8E%B2%E7%94%B5%E5%BD%B1/</url>
      <content type="html"><![CDATA[<p>陆陆续续看完一遍冯小刚的我不是潘金莲，没来得及看原著，不过私以为原著一定比电影要精彩。前段时间刚看完刘震云的书一句顶一万句，那种说话的方式和叙述事情的路子，那种平平淡淡、真真实实，把一件事情不同层面所看到的情况由浅到深的铺开展平，简单朴实的语言一点不炫技，一听便知道是刘震云在讲故事，如果故事的旁白由刘震云来的话，可能更容易让读者共鸣。这部电影如果没有圆形构图，刘震云的影子比冯导的影子明显多了！<a id="more"></a></p>
<p>冯导自己应该也意识到这点，为了突出自己的贡献，用圆形构图来表达自己的存在感。相较这个故事，什么表现形式我觉得不那么重要，或者说形式不应该太强，痕迹太重，太强太重就容易喧宾夺主，有卖弄之嫌。好在，这个形式有些美感在里头，把风景色彩拍得很美，冯导不愧是美工出生！</p>
<p>看的过程中，我就一直在思考一个问题，李雪莲为什么会坚持十几年做一件事情呢？这背后的原因究竟是什么？我尝试在浪漫和现实两者间寻找答案。李雪莲到底是现实的还是有浪漫情怀的呢？在展开叙述前，有必要区分我所说的浪漫和男女间的浪漫，这里讨论的浪漫比男女的浪漫含义更大更广，是所有人的生活的浪漫。</p>
<p>在我看来，这世上的人都是既现实又浪漫，无非是有时候现实多一点，有时候浪漫又多一点。理解同意这点，平常遇到的很多奇怪的人、很多无法理解的事就自然顺理成章。人现实，是因为要面对生活的实实在在，日子要一天一天的过，饭要一口一口的吃，路要一步一脚印的走，所以要现实一些才能做到以上的事，或者说现实是因为我们眼前充满了各种细节，只有一个一个去面对这些细节才能维持生活；人浪漫，是因为如果只有现实，或者说只看到眼前的现实，人就会问自己为什么要这么辛苦这么劳累的注意生活中的细节。只有现实的话，生活就失去意义，就成了对人的惩罚，没了盼头，变成过好过差一个样，过与不过一个样，和谁过一个样，今天和明天一样过。用刘震云说的话，就是生活的细节太多，让人感觉太实在，而人是需要虚一些，这个虚在我看来就是浪漫。如果可以比方的话，现实就是登山时脚下走过路，路上遇到的人，人和你说的话；浪漫则是从远处离开山各个角度看到的样子的总和，包括山的周边环境、走势、高度等等。</p>
<p>简单说，现实是因为我们从细节、从底层看到的生活，浪漫则是从宏观、从上层看到的生活。如果这个成立的话，那么对于生活，人离他远点就看到浪漫多一点，离他近点就看到现实多一点。生活是同时浪漫和现实的，某一个时刻我们看到的只能是一面，能看到生活的样子只取决人看他时处的位置。需要强调的是，人的位置如果容易看到现实，那么那个时候那个位置就不容易看到浪漫，反之亦然。这个特点让我想到量子理论中的测不准原理，在量子理论中，想同时准确的测出一个微观粒子的速度和位置是不可能的，测速度精确时，位置就不确定；测位置精确，测速度又不准确。生活的道理也是一样，如果习惯站在远处看生活，看到的生活就是浪漫的，但站在远处就看不清生活的细节，体会不到生活的现实；如果习惯站在细处看生活，看到的生活就是现实的，但这时就看不清生活的全貌，体会不到生活的浪漫。因此，我把这种人不可能同时体会浪漫和现实的道理称为生活测不准原理，以方便叙述。既然生活测不准，那们我们现实的时候，就浪漫不起来，浪漫的时候，也一点不现实了吗？如果考虑生活变化是缓慢的，尤其从宏观角度看更是这样，那么人还是容易做到既现实又浪漫，只要我们愿意从不同角度看待生活中的事情。</p>
<p>而现实情况又是怎样呢？大多数人不习惯变换看待生活的角度，习惯了一个视角就默认只有这个视角看待生活，以为这就是生活的全部，自己看到了生活的真想。如果一个人给我现实的感觉，那么他往往习惯去关注很多生活的细节，甚至用放大镜去看生活的缺陷，对他人和自己挑剔，幻想并切实努力把每个细节都做到最好，这些在我看来都是偏向现实的。至于那些完美主义者，则更是极端的现实。因为太过于专注细节，到最后都不知道为什么要专注细节的hih，就被细节完全束缚捆绑起来，很难再远离眼前的细节从一个浪漫的角度看生活。最严重的现实者还会排斥抵触浪漫，认为不能当饭吃、不实实在在的东西，就不是生活，就是和生活为敌；反过来，如果一个人给我浪漫的感觉，这个人则又习惯站在生活的另一个端点看问题，追求往往不真实的、虚幻的东西，享受刺激，觉得自己高人一等，从骨子里看不起那些现实的人，而且在心里甚至生活里和现实的人划清界限。如果用一句话来总结上面这段话：这个世界上大部分的人都要么现实得厉害、要么浪漫得厉害，特色分明！</p>
<p>如果仔细观察上面提到的两种人的话，发现没有一种过得舒心、过得大度从容。两者互相看不惯，相互为敌，原因就是执着于自己看到的生活，同时确信自己看到就是真实的生活，哪里知道真实的生活既不浪漫又不现实。这么说的话，难免让现实的人和浪漫的人都失去希望，好在生活还可以等效的描述为既是浪漫的同时也是现实的，而人要做的事情就很简单：敞开心眼，主动愿意从不同角度看生活。具体说来，习惯从细处看问题的人也主动从宏观整体看问题，习惯从整体角度看问题的人也尝试从细节考虑问题。如果真的做到这些，我想生活的真相就离我们进了一大步，或者说我们就更靠近生活的真相，过得从容大度。</p>
<p>回到电影的讨论，李雪莲在我看来就是一个浪漫的人，她的眼里心里只有一个简单的诉求：洗清自己，打倒昏官。按照上面的讨论，这个诉求就是浪漫的，因为诉求是宏观性的，整体的不牵涉具体细节的。但如何能达成这个诉求，一个农村妇女，知识和见识决定了她没有把握细节的能力，不能一步一个脚印的去实现自己的诉求，比如收集证据、聘请律师、学习法律、获得关注等。如果说李雪莲还是实际做了什么事情去实现自己的浪漫的话，她所做的只有普通国人不用想都知道的，比如：和官员攀亲戚、越级举报、拦路告状、磨刀杀人、投奔远亲旧友。这些不用想就轻易得到的方法，并没有什么实际效果，不足以支撑她的浪漫，或者说和她的浪漫比起来显得微不足道，只增烦恼。由于没有现实的方法达成她的浪漫的诉求，这个浪漫的诉求慢慢就不在是一个浪漫的诉求，它慢慢变得空洞，没有任何理由，没有答案的诉求。遗憾的是，她最后也没能如愿自己的诉求，秦玉河之死让潘金莲的帽子摘不掉，也让各级官员的帽子保住了。更遗憾的是，她没有尝试从生活的实际出发去考虑这个诉求的可能性，可操作性，如何才能达成自己的浪漫。最后故事就成了一个浪漫过余，现实不足的故事。换一个角度看这个故事，我们还可以说现实是重要的、需要的，光有浪漫不靠谱！如果说从这个故事还看到什么，那就是一个人有了一个离眼前的现实太遥远的想法到底是好事还是坏事，就像王小波在黄金年代说的一只鸡有了飞上天的想法一样，离自己的实际太遥远。</p>
<p>李雪莲最后和史县长在饭馆偶遇时的妆容和回忆，真的让人心疼，也让这个故事以悲剧收场。一件十几年坚持的事情，当事人却因此变得木讷萎靡，眼神看出已经彻底放弃浪漫的想法回归生活。这可不就是大部分浪漫的人的结局吗? 现实中，很多人都是年轻时有很大的追求，这个时候的眼睛放光、干劲十足、身体敏捷。可最后，很多人终因为只是在目标的浪漫上用功，在如何达到这个浪漫的现实上没有用功，或者说没有看到浪漫的当下就是现实，最后渐渐对浪漫的想法失去信心，变得一个现实的没有浪漫的人。按照前面的讨论，就是开始去近距离看生活了，没了目标茫茫然的或者，生活变成了时间的流逝！我想李雪莲就变成这么一个人，浪漫没了，李雪莲也变得现实了。当坚持的事情变成了别人眼中的笑话，自己想起来都会发笑时，那个浪漫的李雪莲就真的死了！</p>
]]></content>
      
        
        <tags>
            
            <tag> 不同的视角 </tag>
            
            <tag> 电影 </tag>
            
            <tag> 浪漫 </tag>
            
            <tag> 现实 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[看书cpp primer]]></title>
      <url>https://ptbws.github.io/2017/03/04/%E7%9C%8B%E4%B9%A6cpp%20primer/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h2 id="Chapter-2-Variables-and-Basic-types"><a href="#Chapter-2-Variables-and-Basic-types" class="headerlink" title="Chapter 2. Variables and Basic types"></a>Chapter 2. Variables and Basic types</h2><h3 id="2-3-Compound-types"><a href="#2-3-Compound-types" class="headerlink" title="2.3 Compound types:"></a>2.3 Compound types:</h3><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p>reference是一个object的alis,别名。这句话怎么理解？我们首先必须定义一个对象，然后这个对象本身有一个名字，然后才能用reference给这个对象取一个别名，这个别名和本名都是同一个对象，用别名或本名都可以对这个对象操作。也就是说，reference本身不是个对象，因此就不存在reference的reference了，这点和指针本质的区别。</p>
<ul>
<li><p>为什么用别名呢？<br>这个主要是在调用函数的时候使用，我们都知道调用函数默认是pass-by-value,如果这个希望在函数中也操作同一个对象，我们之前知道用pointer,但pointer是底层的一种操作方式，灵活多变但很容易出错，这个时候就可以用reference了，函数的入口参数是一个reference就可以解决让函数操作同一个对象了。</p>
</li>
<li><p>reference和指针的不同是什么？<br>reference只是给已经存在的对象起了一个名字，因此reference和普通的对象一样，在同一个层次，而且一旦针对某个object取了名字，这个名字就不能给其他对象取了，也就是说reference不灵活，这个不灵活从另一个角度看就是reference使用更简单更安全。总结：reference在创建的时候就需要初始化，而且创建后就不能修改，一般用在函数传递时操作同一个对象。问题来了，reference和指针区别是啥？两者在使用的时候，都可以在函数调用时让函数操作同一个对象。我认为区别就是，reference由于不能修改指向的位置，因此是固定的，可以把reference看成const指针，所以，如果希望在调用函数时被指的对象能发生变化，那么妥妥就是指针了，如果没打算改变，就reference效果一样还不错</p>
</li>
</ul>
<h4 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h4><p>指针和reference最大不同是：指针是一个对象，有地址存指针。所以，指针就可以创建的时候不指向任何对象，即使指向某个对象还可以修改指向别的对象。</p>
<ul>
<li>指针和reference的关联<br>指针是对象，而reference不是对象，因此没有指向reference的指针，但反过来说：reference to　pointer就可以。</li>
</ul>
<h3 id="2-4-const-qualifier"><a href="#2-4-const-qualifier" class="headerlink" title="2.4 const qualifier"></a>2.4 const qualifier</h3><p>const就是某个变量的值不改变，因此，首先要有个变量，然后这个变量还需要有初值，这个时候在这条define的语句前加const关键字就可以了。例如：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">cost int bufsize</span>=512;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>const+extern<br>const的变量，默认情况是local to a file,也就是在一个file内可见，如果希望别的file也可见，可以在加extern 来标志：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//file_1.cc</span></div><div class="line"><span class="keyword">extern</span> cost <span class="keyword">int</span> bufsize=<span class="number">512</span>;<span class="comment">//定义</span></div><div class="line"><span class="comment">//file_1.h</span></div><div class="line"><span class="keyword">extern</span> cost <span class="keyword">int</span> bufsize;<span class="comment">//声明</span></div></pre></td></tr></table></figure>
</li>
<li><p>const+reference<br>c++麻烦就麻烦在，太多名词，而且名词之间相互搭配，还有很多exception.这里就遇到一个。我们之前说过，reference本身不是对象，不能单独存在，需要依附已经有的对象，但有例外：如果const+reference，reference就可以指向对象，literal, or a more general expression.也就是说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=i;<span class="comment">//ok：const reference to object</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2=<span class="number">42</span>;<span class="comment">//ok:const reference to literal</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3=r1*<span class="number">2</span>;<span class="comment">//const reference to expression</span></div><div class="line"><span class="keyword">int</span> &amp;r1=r*<span class="number">2</span>;<span class="comment">//error</span></div></pre></td></tr></table></figure>
<p>上面的做法可以这么理解：由于是const，也就是不能通过reference去修改，由于不能修改，那么变量可以，常量也一样了。const＋reference让问题变得简单，所以限制变少，这样理解就容易了！<br>另一个，const+reference只是说通过这个reference不能修改对象，但是一个对象可能有多个reference,通过non-const reference仍然可以修改原来对象。</p>
</li>
</ul>
<h3 id="2-5-Dealing-with-types"><a href="#2-5-Dealing-with-types" class="headerlink" title="2.5 Dealing with types"></a>2.5 Dealing with types</h3><p>随着程序变得复杂，类型也变得复杂。导致两个问题：</p>
<ul>
<li>类型名称太长，太长就导致意义不清晰，写起来也容易出错</li>
<li>不晓得一个结果应该是什么类型，这时候又需要回头去看代码细节，弄明白类型是什么，很头痛</li>
</ul>
<p>如何handle复杂的类型？</p>
<h4 id="type-aliases"><a href="#type-aliases" class="headerlink" title="type aliases"></a>type aliases</h4><p>传统的是用：typedef<br>c++11有新方法：using SI=Sales_item;这个更容易理解</p>
<ul>
<li>pointers+const+type aliases<br>用typedef遇到指针的话，有新的情况需要clarify:<br>例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</div><div class="line"><span class="keyword">const</span> pstring cstr=<span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr1=<span class="number">0</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>说明：cstr和cstr1不同。pstring是指针，所以const pstring表示cstr是一个const pointer;而后面一句中，const是修饰char,所以cstr1表示指向const char的指针。这个区别的原因是：用typedef得到的类型由于先bind成一个整体，在使用的时候这个整体再和其他的限定符来组合；而直接使用typedef中原来类型，则这些类型就不能有限组合了。继续思考，就是typedef相当于下面：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (<span class="built_in">char</span>*) <span class="built_in">cstr</span>=<span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>也就是说typedef优先级更高，相当于加括号，优先级高因此和其他的限定符就不是一个层次的了。c++虽然细节很多，但有意思！</p>
<h4 id="the-auto-type-specifier"><a href="#the-auto-type-specifier" class="headerlink" title="the auto type specifier"></a>the auto type specifier</h4><p>auto的使用，类型由编译器来自动匹配。(略)</p>
<h2 id="Chapter-3-strings-vectors-and-arrays"><a href="#Chapter-3-strings-vectors-and-arrays" class="headerlink" title="Chapter 3. strings,vectors, and arrays"></a>Chapter 3. strings,vectors, and arrays</h2><h3 id="3-1-namespace"><a href="#3-1-namespace" class="headerlink" title="3.1 namespace"></a>3.1 namespace</h3><p>用namespace可以解决名称的conflict.说透了，就是同一个代码，同一个名字，因为属于不同的namespace,就不同了，就不矛盾了，或者说不同namespace的变量和函数处于不同的世界或层次，虽然眼睛能看到的是放在一起，但由于属于不同namespace，就导致他们之间有看不见的鸿沟</p>
<h3 id="3-2-strings"><a href="#3-2-strings" class="headerlink" title="3.2 strings"></a>3.2 strings</h3><h4 id="string初始化"><a href="#string初始化" class="headerlink" title="string初始化"></a>string初始化</h4><p>-　有两种，一种是：copy initialization;一种是direct initialization.如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s5=<span class="string">"hiya"</span>; <span class="comment">//copy</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">"hiya"</span>)</span></span>;<span class="comment">//direct</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//direct</span></div></pre></td></tr></table></figure></p>
<p>有=就是copy初始化，因为编译器会先把等号右边的string literal变成一个string tmp,然后把这个tmp复制给新建的，一件事就变成了两道工序，慢还费空间。</p>
<h4 id="string运算"><a href="#string运算" class="headerlink" title="string运算"></a>string运算</h4><p>string加法：原则是做加法的两个对象必须有至少一个是string,不能两个string literal相加。<br>举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s4=s1+<span class="string">","</span>;//ok</div><div class="line"><span class="built_in">string</span> s4=<span class="string">"hello"</span>+<span class="string">","</span>;//<span class="built_in">error</span>.两个常量加不可以</div><div class="line"><span class="built_in">string</span> s4=s1+<span class="string">","</span>+<span class="string">"world"</span>;//ok.因为s1+<span class="string">","</span>返回一个<span class="built_in">string</span> tmp,tmp+<span class="string">"world"</span>，这就是级联的效果</div><div class="line"><span class="built_in">string</span> s4=<span class="string">"hello"</span>+<span class="string">","</span>+s2;//<span class="built_in">error</span>.<span class="string">"hello"</span>+<span class="string">","</span>不能够</div></pre></td></tr></table></figure></p>
<h3 id="3-3-vectors"><a href="#3-3-vectors" class="headerlink" title="3.3 vectors"></a>3.3 vectors</h3><p>vector是容器。</p>
<h4 id="vector初始化"><a href="#vector初始化" class="headerlink" title="vector初始化"></a>vector初始化</h4><p>两种方式，一种list initializer,一种element count.如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>)；<span class="comment">//element count:10个元素初值0.</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">10</span>&#125;；<span class="comment">//list initializer.一个元素10</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>,<span class="number">1</span>)；<span class="comment">//element count:10个元素初值1.</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">10</span>,<span class="number">1</span>&#125;；<span class="comment">//list initializer.两个元素10和1</span></div></pre></td></tr></table></figure></p>
<h3 id="3-4-introducing-iterators"><a href="#3-4-introducing-iterators" class="headerlink" title="3.4 introducing iterators"></a>3.4 introducing iterators</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> b=v.<span class="built_in">begin</span>(),e=v.<span class="built_in">end</span>();</div></pre></td></tr></table></figure>
<p>b指向v的第一个元素，e指向v的最后元素的下一个位置，也就是不是最后一个元素，这是一个很容易忽略的问题，自己写代码就犯过错，把end()误当成是v的最后一个位置。那为什么这么设置呢？如果不这么设置，而让.end()指向v的最后一个元素，那么当v只有一个元素时，v.begin()==v.end(),当没有元素的时候，就表示不了了，所以这么设置的目的，是为了方便表示空的情况,即：当v.begin()==v.end()，v为空。这么想，就容易理解了！</p>
<p>iterator的操作有==,!=,++,–等。注意没有定义大于或小于符号，因此就用不等号和遍历的方向就够了.</p>
<ul>
<li>iterator types<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</div><div class="line"><span class="built_in">string</span>::iterator it2;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>说明：const_iterator就是表示这个iterator是const,只能用来读，不能用来写，相当于const指针，也就是规定了权限。</p>
<ul>
<li>iterator arithmetic<br>对vector和string的iterator,支持一次移动n步，例如：<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">iter+n</span></div><div class="line"><span class="keyword">iter-n</span></div><div class="line"><span class="keyword">iter+=n</span></div><div class="line"><span class="keyword">iter-=n</span></div><div class="line"><span class="keyword">iter1-iter2</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>支持一次移动多个位置的原因，是因为vector和string是顺序container,也就是元素在内存中是连续的存放的，所以这么计算对编译器没难度，都是o(1)的操作，而其他复杂数据结构的iterator就不支持这样的操作。由于是顺序的container,所以除了支持相等不等，还支持大于小于这些比较操作，使用起来更方便更灵活，不过其他非顺序container就没这个运算了。</p>
<h3 id="3-5-arrays"><a href="#3-5-arrays" class="headerlink" title="3.5 arrays"></a>3.5 arrays</h3><p>array相对vector，长度是固定的，在编译的时候就确定了，如果应用长度是事先就固定的已知的，就可以用array，因为array的速度快。</p>
<h4 id="识别复杂的类型符号"><a href="#识别复杂的类型符号" class="headerlink" title="识别复杂的类型符号"></a>识别复杂的类型符号</h4><p>例如，<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> *ptrs[<span class="number">10</span>];//从右往左结合：ptrs是放<span class="number">10</span>个指针的<span class="built_in">array</span></div><div class="line"><span class="built_in">int</span> (*<span class="type">Parray</span>)[<span class="number">10</span>]=&amp;arr;//先看括号内的，括号内的一个指针，括号外用从右往左结合，<span class="number">10</span>个<span class="built_in">int</span>的<span class="built_in">array</span>,所以就是一直指针指向<span class="number">10</span>个数的<span class="built_in">array</span></div><div class="line"><span class="built_in">int</span> (&amp;<span class="type">Parray</span>)[<span class="number">10</span>]=&amp;arr;//先看括号内，一个reference,所以，<span class="type">Parray</span>是<span class="number">10</span>个数的<span class="built_in">array</span>的reference</div><div class="line"><span class="built_in">int</span> *(&amp;rarray)[<span class="number">10</span>]=ptrs;//先看括号，rarray是reference,然后看外面，<span class="number">10</span>个指针的数列，所以整个就是rarray是<span class="number">10</span>个指针的数列的reference.</div></pre></td></tr></table></figure></p>
<h2 id="Chapter-6-Functions"><a href="#Chapter-6-Functions" class="headerlink" title="Chapter 6. Functions"></a>Chapter 6. Functions</h2><h2 id="Chapter-7-Classes"><a href="#Chapter-7-Classes" class="headerlink" title="Chapter 7. Classes"></a>Chapter 7. Classes</h2><p>这章讲类的概念。所谓类，就是c++和c的区别之一：data abstraction和encapsulation思想的具体实现。</p>
<ul>
<li><p>什么是data abstraction?<br>data abstraction:一种设计方法，依赖接口和实现的分离。简单说，接口就是功能，这个类对外宣称可以实现的具体功能是什么，这个叫接口；实现则是功能的具体实现方法和细节，同一个接口或功能，可以采用不同的实现细节。接口或功能是对类外面的使用者而言，或者说是从外面看到的类的样子，实现细节则是被包裹在类以内，从外面是无法接触无法看到无法感觉得到的，因此可以认为实现细节是从类的内部看到的。因此，还可以说接口是类的外表，实现则是类的内涵。前面说了这么多功能和细节分离的理念。那什么是data abstraction? 书上也没说清楚，论坛帖子也没说明白。<br>我自己的理解是，(以后有新的理解可以继续更新),abstraction就是站在类或对象之外看到的对象，由于对象是encapsulation的，所以能看到的只有接口或功能。</p>
</li>
<li><p>什么是encapsulation?<br>封装和data abstraction相对的概念，如何相对？data abstraction是站在类外面看到的，而封装则是站在类里面看到的组织结构，即：类的结构是就接口或功能以及这些功能的实现，接口或功能是对外的形象，功能的实现则是类的内涵。<br>写了一个答案，发现没地方放，就放这里：</p>
<blockquote>
<p>I would like to conclude the difference into one sentence for easy comprehension. Abstraction and encapsulation are different sayings from two opposite views. Abstraction is what we see when  standing outside of the class/object, while encapsulation is what we see when standing inside the class/object.</p>
</blockquote>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[c++复习]]></title>
      <url>https://ptbws.github.io/2017/03/03/cpp%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h2 id="Ch1-Accustoming-yourself-to-C"><a href="#Ch1-Accustoming-yourself-to-C" class="headerlink" title="Ch1: Accustoming yourself to C++"></a>Ch1: Accustoming yourself to C++</h2><h3 id="Item-1-view-c-as-a-federation-of-languages"><a href="#Item-1-view-c-as-a-federation-of-languages" class="headerlink" title="Item 1: view c++ as a federation of languages"></a>Item 1: view c++ as a federation of languages</h3><p>这个观点不错，把c++按特点分成四个子类：</p>
<ul>
<li><p>c语言。包括array,pointer,function,block statements, preprocessor等过程描述</p>
</li>
<li><p>OOD: 面向对象设计。包括class(constructor, desctructor), encapsulation(这是什么？), inheritance, polymorphism(这是什么？), virtual functions(dynamic binding)</p>
</li>
<li><p>template c++:模板。generic programming.</p>
</li>
<li><p>The STL: template library.</p>
</li>
</ul>
<h3 id="Item-2-prefer-const-enum-and-inline-to-define"><a href="#Item-2-prefer-const-enum-and-inline-to-define" class="headerlink" title="Item 2: prefer const, enum, and inline to #define"></a>Item 2: prefer const, enum, and inline to #define</h3><p>这个有体会。少用preprocessor，少用宏，多用compiler。</p>
<ul>
<li>用const代替宏：例如：#define RATIO 1.653,定义并使用前面的宏，如果调试的时候，报错会直接包1.653,在代码里并没有RATIO这个量，所以调试很困难，这种情况就用const double ratio=1.653。</li>
<li><p>再比如：用宏得到的常量全文件有效，除非用#undef解除；用const就有scope。</p>
</li>
<li><p>使用enum，也可以得到常数，例如：enum {NumTurns=5};和const比，好处是可以让使用的人不能得到这个常数的地址，而用const的地址就可以用&amp;来得到，这么看，enum还有个保密的功能。</p>
</li>
<li><p>使用inline +template，不用带参数的宏。例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define MAX(<span class="name">a</span>,b) ((<span class="name">a</span>)&gt;(<span class="name">b</span>)?(<span class="name">a</span>):(<span class="name">b</span>))</div></pre></td></tr></table></figure>
</li>
</ul>
<p>为了防止输入参数是一个expression,每个参数都要用括号。即使这样，仍然有loophole,例如：MAX(++a,b),这个就会导致a加了两次，仍然是不能保证正确啊。所以用inline来替代，为什么还用template?因为参数宏的优点是没有类型，所以用template就可以模拟没有类型要求的特性。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp;a,<span class="keyword">const</span> T&amp;b)</span></span>&#123;<span class="comment">//inline应该放在返回值前</span></div><div class="line">    <span class="keyword">return</span> a&gt;b?a:b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Item-3-use-const-whenever-possible"><a href="#Item-3-use-const-whenever-possible" class="headerlink" title="Item 3: use const whenever possible"></a>Item 3: use const whenever possible</h2><p>用const的原因是告诉compiler，还有编程的人，这个变量不能修改。这里又讲了const data+const pointer这个概念：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">char</span> greeting[]=<span class="string">"hello"</span>;</div><div class="line"><span class="built_in">char</span> *p=greeting;//non-<span class="keyword">const</span> <span class="built_in">pointer</span>,non-<span class="keyword">const</span> data</div><div class="line"><span class="keyword">const</span> <span class="built_in">char</span> *p=greeting;//<span class="keyword">const</span> data,non-<span class="keyword">const</span> <span class="built_in">pointer</span></div><div class="line"><span class="built_in">char</span>* <span class="keyword">const</span> p=greeting;//<span class="keyword">const</span> <span class="built_in">pointer</span>,non-<span class="keyword">const</span> data</div><div class="line"><span class="keyword">const</span> <span class="built_in">char</span>* <span class="keyword">const</span> p=greeting;//<span class="keyword">const</span> data,<span class="keyword">const</span> <span class="built_in">pointer</span></div></pre></td></tr></table></figure>
<ul>
<li>const member functions<br>这个是说class里面的member function不会修改class的私有成员，在函数第一行末尾添加const标识</li>
</ul>
<p>## </p>
]]></content>
      
        
        <tags>
            
            <tag> c++，找工作 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c语言复习]]></title>
      <url>https://ptbws.github.io/2017/02/22/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="面试中遇到的问题："><a href="#面试中遇到的问题：" class="headerlink" title="面试中遇到的问题："></a>面试中遇到的问题：</h2><h3 id="if-else为什么每次运行结果不同，可能原因？"><a href="#if-else为什么每次运行结果不同，可能原因？" class="headerlink" title="if-else为什么每次运行结果不同，可能原因？"></a>if-else为什么每次运行结果不同，可能原因？</h3><ul>
<li>本问过一次。说编译器没问题，代码的问题，每次编译结果不同，为什么。最后知道答案是：条件判断的变量没有初始化，导致每次编译运行的时候初值是undefined，所以结果就是随机的。</li>
</ul>
<h3 id="c语言中unsigned-int和int做运算，会自动把int转换成unsigned-int再运算，结构也是unsigned"><a href="#c语言中unsigned-int和int做运算，会自动把int转换成unsigned-int再运算，结构也是unsigned" class="headerlink" title="c语言中unsigned int和int做运算，会自动把int转换成unsigned int再运算，结构也是unsigned."></a>c语言中unsigned int和int做运算，会自动把int转换成unsigned int再运算，结构也是unsigned.</h3><h3 id="malloc-和calloc-的区别是什么？"><a href="#malloc-和calloc-的区别是什么？" class="headerlink" title="malloc()和calloc()的区别是什么？"></a>malloc()和calloc()的区别是什么？</h3><ul>
<li><p>刚问了cplusplus.com.总结一下区别: void* malloc(size_t size):前面的void*看起来不眼熟，但只要把void换成int,就知道怎么回事了。int*表示指向int型数据的指针 ，也就是地址；同理，void*则表示指向一个地址，但是这个数据的类型可以是任何数据类型。malloc(size_t size)函数入口参数是分配的空间大小，确切说是分配的byte数量，因此这个空间存储什么数据类型必须明确告诉malloc,例如：<a id="more"></a></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*) <span class="built_in">malloc</span> (i);</div><div class="line"><span class="comment">//i表示byte数量</span></div></pre></td></tr></table></figure>
<p> 在上面malloc()前面的(char*)，如何理解？参考了网络文章，发现是强制类型转换，具体说，就是把malloc返回的void*强制转换成指向char的指针，也就是说void*可以被强制类型转换成其他类型。</p>
</li>
<li><p>类似的，calloc()语法是：void* calloc (size_t num, size_t size); 和malloc不同的是，calloc有两个入口参数，一个表示分配空间存的元素的个数，注意不是byte的个数，这两个是有区别，另一个表示存的元素占用的byte数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* pData = (<span class="keyword">int</span>*) <span class="built_in">calloc</span> (i,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"><span class="comment">//(int*)强制类型转换</span></div></pre></td></tr></table></figure>
<p>cplusplus就是写得透彻。这<strong>两者的区别</strong>一句话就说明白：malloc以字母m开头，表示的是从memory角度来看这个分配，memory是不分别数据类型的，一律用byte的数量表示memory分配大小，所以malloc一个入口函数就够了，毕竟底层器件能看到的世界和上层不同；calloc：就是contiguous allocation,为什么叫连续分配？因为他是从c语言的角度，而不是从存储器角度，来分配的。从c语言，如果我现在要存100个int，和存100个char，相同的是都要分配100个空间，不同的是每个空间大小不一样。所以，连续分配是指连续分配n个size相同的空间，每个空间的size需要单独指定。</p>
</li>
<li>两种区别一句话表示为：malloc is to allocate memory block; calloc is to allocate and zero-initialize array.</li>
<li>由于是动态内存管理，分配使用后，必须手动释放，所有上面两种分配都需要free(指针)</li>
</ul>
<h3 id="short-int-long长度？由于不同系统对同一个数据类型，比如long，定义是不一样，-如何保证代码的可移植性呢？"><a href="#short-int-long长度？由于不同系统对同一个数据类型，比如long，定义是不一样，-如何保证代码的可移植性呢？" class="headerlink" title="short,int,long长度？由于不同系统对同一个数据类型，比如long，定义是不一样， 如何保证代码的可移植性呢？"></a>short,int,long长度？由于不同系统对同一个数据类型，比如long，定义是不一样， 如何保证代码的可移植性呢？</h3><ul>
<li>在32位系统中，short表示2 byte, int 4 byte, long 8byte.为了移植，用typedef 来自己重命名类型,例如： typedef int int16，把int命名成int16,如果移植到32位系统，那么只需要修改typedef的定义即可，不用全部替换，例如：typedef short int16</li>
</ul>
<h3 id="include-和include-“header-h”区别"><a href="#include-和include-“header-h”区别" class="headerlink" title="include 和include “header.h”区别"></a>include <header.h>和include “header.h”区别</header.h></h3><ul>
<li>&lt;&gt;表示编译器首先去标准库里搜索这个头文件；“”表示是用户自定义的头文件，因此去当前目录查找</li>
</ul>
<h2 id="网络搜集的问题-amp-看书C-Promgramming-A-modern-approach"><a href="#网络搜集的问题-amp-看书C-Promgramming-A-modern-approach" class="headerlink" title="网络搜集的问题&amp;看书C Promgramming: A modern approach"></a>网络搜集的问题&amp;看书C Promgramming: A modern approach</h2><h3 id="typedef和-define区别？"><a href="#typedef和-define区别？" class="headerlink" title="typedef和#define区别？"></a>typedef和#define区别？</h3><ul>
<li>总的说来，typedef比＃define更powerful.define就是简单的替换，在preprocessing时完成；typedef是在编译的时候完成，和variable一样，有作用域和生存周期，而且typedef末尾有分号，表示是一句代码，而#define末尾没有符号。上面的讨论说明一个啥问题呢？预编译器的功能和编译器比起来，功能简单，能做的事有限。这么说就解释了typedef强大，而#define就弱，弱是因为preprocessor弱所导致！</li>
<li>typedef只能给一个类型重命名；#define还可以定义常量。</li>
<li><p>两者的区别，下面的例子很说明问题，参考了大神解释，<a href="http://stackoverflow.com/questions/1666353/are-typedef-and-define-the-same-in-c" target="_blank" rel="external">http://stackoverflow.com/questions/1666353/are-typedef-and-define-the-same-in-c</a>　一句话，typedef定义指针啊，复杂类型啊，很好用；而define就弱很多</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* int_p1;</div><div class="line">int_p1 a, b, c;  <span class="comment">// a, b, and c are all int pointers.</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> int_p2 int*</span></div><div class="line">int_p2 a, b, c;  <span class="comment">// only the first is a pointer!</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> a10[<span class="number">10</span>];</div><div class="line">a10 a, b, c; <span class="comment">// create three 10-int arrays</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func_p)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line">func_p fp <span class="comment">// func_p is a pointer to a function that</span></div><div class="line">          <span class="comment">// takes an int and returns an int</span></div></pre></td></tr></table></figure>
</li>
<li><p>define是宏定义，由于有#在前，因此和#include一样，是预编译指令，所谓预编译，是在正式的compile之前需要做的事，做什么呢？例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INCHES_PER_POUND 166</span></div></pre></td></tr></table></figure>
<p>就是简单的数据替换，在代码中遇到INCHES_PER_POUND,就替换成166。还可以做什么呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RECIPROCAL_OF_PI (1.0f/3.14159f)</span></div></pre></td></tr></table></figure>
<p>上面的例子在替换之前，还需要做简单的运算，但这里值得注意的是，需要把运算表达式用parentheses enclosed，否则不运算，而直接用后面的表达式替换。另外，用大写也是个约定俗成的不是规定的规定。</p>
</li>
</ul>
<h3 id="用int如何保存-2-31"><a href="#用int如何保存-2-31" class="headerlink" title="用int如何保存$2^{31}$?"></a>用int如何保存$2^{31}$?</h3><ul>
<li>int的范围是$-2^{31}$到$2^{31}-1$，因为要表示0嘛。所以正数的表示范围比负数范围的小1，如果非要表示$2^{31}$，要么用long，要么用unsigned int。</li>
</ul>
<h3 id="运算符的优先级顺序是怎样的？"><a href="#运算符的优先级顺序是怎样的？" class="headerlink" title="运算符的优先级顺序是怎样的？"></a>运算符的优先级顺序是怎样的？</h3><ul>
<li>最先计算的是单目运算符号，例如！，+，-</li>
<li>然后是*,/,%</li>
</ul>
<h3 id="if-和switch区别："><a href="#if-和switch区别：" class="headerlink" title="if 和switch区别："></a>if 和switch区别：</h3><ul>
<li>switch：判断的对象如果是一个变量，且是int或char。使用时，每个分支执行完，需要break;语句,否则会顺序执行后面的语句，所以说c语言确实是比较底层的语言，和机器打交道的，比较low</li>
<li>if:使用无限制</li>
</ul>
<h3 id="stack-vs-heap"><a href="#stack-vs-heap" class="headerlink" title="stack vs heap?"></a>stack vs heap?</h3><ul>
<li>stack是静态内存分配，是自动的分配,在编译之前就知道需要分配多大空间，就用stack,使用完成后，自动释放，用来存local的变量；heap是动态内存分配，在run-time的时候才知道需要多大空间，而且用指针访问，所以慢，由于是动态的，所以不知道会使用多久，因此需要用户explicit deallocate,<br>－两者共同的地方是都存在ram内。</li>
</ul>
<h3 id="virtural-memory怎么回事？"><a href="#virtural-memory怎么回事？" class="headerlink" title="virtural memory怎么回事？"></a>virtural memory怎么回事？</h3><ul>
<li>虚存并不是c语言的知识，是操作系统的功能。虚存和实际的ram是一个相对的概念，虚存是建立在实际ram之上，但又不等于ram的一套方法。由于c语言需要分配多大内存空间，例如动态内存分配的时候，不是直接和物理ram打交道，而是和操作系统打交道，告诉操作系统这个程序需要多大的内存，操作系统就去准备，正常情况下如果物理内存空间大于需要的空间，就不需要虚存的概念。虚存的提出是解决内存不足的情况。当物理内存只有50MB,而需要120MB,现在操作系统就需要用虚存的方法来解决这个问题，首先发现内存不够，因此就利用hard disk来帮忙，把ram上暂时不适用的内容和hard disk上需要用的内容swap,从c语言的角度看，好像确实有120MB空间存在一样，殊不知这是操作系统屏蔽了如何实现120MB的细节，这个操作系统凑齐120MB的方法就是虚存的概念。</li>
<li>虚存的实现是靠virtual memory manager.在硬盘上划定一块区间，根据需要不断的swap内存和硬盘的内容。</li>
<li>用虚存的原因，上面已经提到是因为内存不够，硬盘来凑。这个内存不够，除了指一个程序需要的内存超过了可用的空间，还包括多个程序同时multi-tasking时所需要的内存操作了可用的空间。</li>
<li>由于虚存要不停的swap，而且访问硬盘，所以虚存的概念是尽力满足需求，但是操作的速度就不保证了。和网络传送的best effort的思想是一样的，网络传送文件会尽力传送，但是如果有网络拥塞，那么就选择一条远的路传，虽然传成功了，但时延却很大。</li>
</ul>
<h3 id="c程序编译的过程？"><a href="#c程序编译的过程？" class="headerlink" title="c程序编译的过程？"></a>c程序编译的过程？</h3><ul>
<li>preprocessing: 预处理。主要是处理#开头的语句，例如：库文件包含，宏定义，通过这些语句修改添加信息进入source code</li>
<li>compiling: 编译。修改后的代码进入编译，编译就是把代码翻译成机器指令</li>
<li>linking: 链接。就是把机器代码转换成可执行代码。</li>
</ul>
<h3 id="printf-时输出格式说明"><a href="#printf-时输出格式说明" class="headerlink" title="printf()时输出格式说明"></a>printf()时输出格式说明</h3><ul>
<li>％m.pX:例如：%10.2f。</li>
<li>m表示minimum field width,就是说输出的字符的数量最小是m个，如果本身这个变量包含的字符数少于m，那么就填空格；如果多于m，有多少输出多少。</li>
<li>p表示精度。对float而言，是小数点后的字符数，如果10.23f让输出的精度为3，那么也就是说需要3位小数位，则填0;对int而言，则表示整数位的个数，例如：23d,要输出精度为3,则输出为023,在前面添０</li>
<li><p>X表示类型，d,f,c,e,g.<br>例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">40</span>;</div><div class="line">float <span class="keyword">x</span>=<span class="number">839.21</span>f;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"|%d|%5d|%-5d|%5.3d|\n"</span>,i,i,i,i);</div><div class="line"><span class="keyword">printf</span>(<span class="string">"|%10.3f|\n"</span>,<span class="keyword">x</span>);</div></pre></td></tr></table></figure>
<p>输出为：<br>|40|   40|40   |  040|<br>|   839.210|<br>需要说明的是：由于输出默认是右对齐，所以在％后面添加-表示左对齐；打印float输出是，m=10，表示输出最小的charactor数，其中包括数字本身，包括添加的0，包括添加的空格，还要包括小数点！</p>
</li>
</ul>
<h3 id="Operator-precedence-and-associativity"><a href="#Operator-precedence-and-associativity" class="headerlink" title="Operator precedence and associativity"></a>Operator precedence and associativity</h3><ul>
<li>运算符优先级和结合顺序：unary Operator(+,-,!)高于binary operator;结合顺序，有从左往右的，例如：+-*/,还又从右往左的,例如:单目运算符，-+i,就是-(+i)</li>
<li>截了个图，你看所有的赋值符号，优先级最低；然后postfix(i++或i–)优先级最高，其次是prefix(++i和--i)<br><img src="http://i.imgur.com/KIY4ukg.png" alt=""></li>
<li>\==，equality operator:优先级低于关系运算符，例如：i&lt;j\==j&lt;k,相当于(i&lt;j)\==j&lt;k,即：先比较左右不等符号，然后在evaluate相等符号。</li>
<li>Logical operator:　！(单目运算符)，&amp;&amp;,||。这里说明几点：<blockquote>
<p>||和&amp;&amp; perform “short circuit” evaluation.也就是说，由于运算结果就只有0,1两种，因此运算过程中只要等于1/0就再也不可能等于0/1的时候，就不用把后面的都给evaluate了，节省时间。例如：a||b,如果a等于1,那么就不用判断b;同理，a&amp;&amp;b,如果a等于0，那么也不用判断b。这就是“short circuit”。这个做法还是有点意思！</p>
<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h3><ul>
<li>书上提到了一个“<strong>dangling case</strong>”:dangling就是悬挂，悬吊的意思。这里用来说明if-else嵌套时配对的问题。例如：<img src="http://i.imgur.com/amo6nFU.png" alt="Drawing (87)"><br>上图，看结构，else是打算和第一个if配合，但是书写的结构和c语言编译的结果不是一回事，看下面，<br><img src="http://i.imgur.com/xvD5FJD.png" alt=""><br>c语言是把else和前面距离最近，且没有配对的if配对在一起。因此，为了防止这个理解错误，即：dangling case,需要用braces把if－else的配对情况表示清楚，不能含混.如下图：<br><img src="http://i.imgur.com/U4W8ebm.png" alt=""></li>
<li>通过这一点，确实应该有时间学一下编译原理，知道编译器如何识别代码的，可以减少很多书写的错误。比如这个if-else，这个配对的过程让我想起括号配对的问题，例如:()(()),你看左括号就是if,右括号就是else.所以，算法的东西也用上了，为了判断是否配对，用一个stack就可以实现。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><ul>
<li>能有switch的地方就能用if,switch就是个特例。如下图：<br><img src="http://i.imgur.com/X96mY8Y.png" alt=""><br>需要说明的是，<blockquote>
<ul>
<li>switch()入口的表达式的结果必须是int或char,char本质就是int，所以可以简化说结果必须是int；</li>
<li>case后面的必须是常数表达式，4+2可以，但4+i不可以</li>
<li>每个case后面的语句是顺序执行，而且必须用break结束，否则会一直顺序执行下去，这就是switch设计得不好的地方了，但为什么这么设计？没说！</li>
<li>当然trick的地方是，有些程序设计员利用switch一旦开始执行就停不下来的特点，故意在某些case后不用break语句，专门让其连续执行，我想说，这个思路可取的地方就是认清了switch麻烦的地方不是去严格执行规定，避免出错，而是大胆挑战这条规矩，也不是挑战，就是换个思路去看所谓的限制，转不利为有利。除开这点不说，说执行效率，我觉得还是比较慢，如下图。你看，当grade等于4,则需要分别执行case 4,3,2,1四条语句，虽然每个语句为空，但是时间就慢了。不过这个敢于转不利为有利的胆识，值得赞叹！<br><img src="http://i.imgur.com/OaUNXYg.png" alt=""></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="Loops-略"><a href="#Loops-略" class="headerlink" title="Loops(略)"></a>Loops(略)</h3><h3 id="Basic-types"><a href="#Basic-types" class="headerlink" title="Basic types"></a>Basic types</h3><h4 id="int讲解："><a href="#int讲解：" class="headerlink" title="int讲解："></a>int讲解：</h4><ul>
<li>如下图。上次面试就出这个题了，问32-bit的机器表示short,int,long的byte数，这就是答案啊。short无疑问2byte，int 4byte,long在32位机器中居然也是4byte.这就是基础，得重视！还要注意的是，unsigned int和int unsigned顺序无关紧要，都表示无符号整型。<br><img src="http://i.imgur.com/9bALVPz.png" alt=""><h4 id="float型：三种。"><a href="#float型：三种。" class="headerlink" title="float型：三种。"></a>float型：三种。</h4></li>
<li>float,double, long doule。float就是单精度，32bit,double用64bit表示。都是用科学计数法表示：符号＋指数＋小数。float中，8bit表示指数，23bit表示小数。<h4 id="自动类型转换-不同数据类型转换。"><a href="#自动类型转换-不同数据类型转换。" class="headerlink" title="自动类型转换: 不同数据类型转换。"></a>自动类型转换: 不同数据类型转换。</h4></li>
<li>为了保证不丢失信息，通常是允许从简单的类型转换转换成复杂类型，比如从int到float，或者是从短类型转到长的类型，比如从int到long。为啥呢？这样做不丢信息，而反过来，就要丢信息，如果丢信息，就有可能把重要信息丢失导致数据转换后四不像。<blockquote>
<ul>
<li>unsigned int和int一起参与运算，会把(signed)int转换成unsigned然后参与运算，结果也是unsigned.因此，最好不要这么来运算，结果往往和预想的不同。这种情况，虽然不会报错，但是会产生warning，因此还是要看warning。<h4 id="casting"><a href="#casting" class="headerlink" title="casting:"></a>casting:</h4></li>
</ul>
</blockquote>
</li>
<li>前面讨论的是自动转换，这里cast就是强制转换，手动档。想起前面的(char*)malloc(m),或者(int*)calloc(m,sizeof(int)),(char*)或(int*)就是强制类型转换，括号里的类型是转换后的类型，那转换前的类型呢？是void*,这是指针，但指向类型没确定。看得出，这个强制类型转换是增加信息的，和自动的不一样。下面有几个cast的用途：<blockquote>
<ul>
<li>除法的时候，希望int相除能保留小数，那么可以这样：float res=(float)i/j;如果直接float res=i/j;则是先按照整数计算，这个时候小数部分已经丢失，然后把这个计算结果自动转换成float；而前一种方法，把参与运算的一个数先转为float,那么编译器看到一个是float,一个是int,就会自动把int转换成float，然后结果就可以保留小数了。</li>
<li>防止overflow,例如：long i=j*j; j是int很大的值，那么相乘后就会溢出，也就是说还没有转换成long之前就overflow了。这个时候就可以用cast了，如：long i=(long)j*j;这么写就是先把其中一个转换成long,然后编译器看到参与运算的一个是long,一个是int,则自动把int转换成long,最后就是long和long的运算，结果自然就是long.　也就是说，运算数，而不是结果转换为长度较长的类型是最安全的。<h4 id="type-definition"><a href="#type-definition" class="headerlink" title="type definition:"></a>type definition:</h4></li>
</ul>
</blockquote>
</li>
<li>typedef int Dollars；这是定义了新类型Dollars,但这个类型本质还是int,或者说Dollars是int的别名synonym.既然这样，那为什么还需要重新取名字呢？有几个好处和用途：<blockquote>
<ul>
<li>int和Dollars从机器角度看都是4byte的数据而已；但从程序员角度看，就差别大了，Dollars除了告诉程序员这个是int,还包含了这个是表示钱的变量，也就是描述问题更加贴近对象，而不是机器。从机器角度换成了问题角度！</li>
<li>方便修改类型，如果在代码后期，发现Dollars数量太大，不能用int表示，需要改成long,我们只需要改成typedef long Dollars；即可。操作起来快速，不用一个一个查找替换，即使你愿意查找替换，而且声称自己很仔细，还是可能因为某一个没有修改完全导致错误。</li>
<li>移植方便。如果在32-bit系统中可以用int就能工作，但是到16-bit系统，则发现要用long才可以，那么不用一个一个修改，直接修改typedef即可！</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="Arrays数列"><a href="#Arrays数列" class="headerlink" title="Arrays数列"></a>Arrays数列</h3><h4 id="const用法"><a href="#const用法" class="headerlink" title="const用法:"></a>const用法:</h4><ul>
<li>书上有个例子如下，在数据类型前面加const的左右是让compiler检查这个数组是否被修改，如果被修改，就报错。也就是说const是给编译器看的，当然也是给程序员看的，程序员一看到这个，就知道不能修改，修改了也没用，编译器不答应！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> hex_chars[]=&#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>...&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><h4 id="function-declarations-函数声明"><a href="#function-declarations-函数声明" class="headerlink" title="function declarations:函数声明"></a>function declarations:函数声明</h4><ul>
<li>如果函数的定义在使用之前，编译器检测到使用之前已经发现这个函数的定义，所以能正确找到这个函数的入口地址；如果函数的定义在使用之后，那么编译器发现需要使用函数的时候，不知道去哪儿找这个函数的入口地址，因为编译是从前往后编译的。为了将就编译器这个特点，也为了程序的设计灵活，如果程序的定义在使用之后，则需要在程序使用之前做一次声明，告诉编译器，我在后面定义了这个函数，不要给我报错，你自己去找。再次说明，学点编译原理有些必要！<blockquote>
<ul>
<li>函数声明就是告诉编译器这个函数入口参数个数，类型，返回值类型等信息，方便编译器进行检查。</li>
<li>函数声明语法上就是函数定义的第一句加上末尾分号。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="array-arguments"><a href="#array-arguments" class="headerlink" title="array arguments:"></a>array arguments:</h4><ul>
<li><p>array作为函数入口参数。array和单个数据不同的地方是，除了类型，还有长度这个参数。也就是说，要描述array继续要类型，还需要长度，所以在c语言里，如果用array做入口参数，需要传递类型，还要单独传递长度，否则函数是不知道这个array的长度。这个后面会解释。举例：</p>
 <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> sum_array(<span class="built_in">int</span> a[],<span class="built_in">int</span> n)<span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>注意上面的例子不能写成下面这样，</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> sum_array(<span class="built_in">int</span> a[n],<span class="built_in">int</span> n)<span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>原因还是编译器设计的问题：当编译器从左往右读到a[n],发现不认识n,即使n就在后面还是不认识，所以就急忙报错。这说明啥？说明c语言编译器没有结合上下文的能耐，最多就是结合上文。有了这个背景知识，那我们可以写成下面的样子，先告诉编译器n的存在，再告诉他a[n]，这么一来它就不出错：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> sum_array(<span class="built_in">int</span> n,<span class="built_in">int</span> a[n])<span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>用array做参数还有一个有趣的地方，就是可以在子函数中直接修改array的内容，不像传递一个值的时候，是pass-by-value。这一点也是需要后面解释的，这个也是编译器的操作有关。学了这么多年，好多奇怪的、不解释的语法和特点，都是设计编译器这帮人在后面搞鬼，搞清楚这点，以后遇到不理解的方法，都可以想想是不是编译器非要这么干不可，一般情况下，编译器设计和程序设计应该独立，但越是底层的语言，这两者就不可能完全独立，你不懂编译器的知识，不知道设计编译器这帮人考虑问题的方式，很多语法现象理解起来就困难，所以为了学底层的语言，编译器的知识还是要的。我估计写编译器这帮人也不得不懂一些底层语言的特点，这么一想也就平衡了，因为都是底层人员嘛。如果只是单方面要求写程序的人理解学习编译器，而他们一点程序设计的知识也不需要学的话，这就不公平了！</p>
</li>
<li><p>现在说说二维array如何传递到函数。例如：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define LEN 10</span></div><div class="line"><span class="built_in">int</span> sum_two_dimensional_array(<span class="built_in">int</span> a[][<span class="type">LEN</span>],<span class="built_in">int</span> n)<span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>看到和一维array的区别了吗？一维的长度是单独作为参数传递，有灵活性，而二维的就只有行数目可以传递，列数目必须在array的表示中明确表示出来，灵活性差一些，书上说可以通过array of pointer来解决这个问题。这个例子还看出，行数量可以省略，而列数量必须明确写出来！</p>
</li>
</ul>
<h3 id="Program-organization-程序架构"><a href="#Program-organization-程序架构" class="headerlink" title="Program organization:程序架构"></a>Program organization:程序架构</h3><p>前9章都是在讨论一个函数的设计会出现什么问题，主要包括：</p>
<blockquote>
<ul>
<li>单个数据类型的表示</li>
<li>同种数据间以及不同类型间的关系：相互运算，就涉及运算优先级和结合顺序，类型转换就涉及自动和强制.</li>
<li>各种语句（选择语句if-else和switch、循环语句while(),do-while和for、）</li>
<li>如果需处理多个同类型的数据，引入array的概念和方法来处理，提高效率；</li>
<li>函数如何调用，声明，参数如何传递，如果入口参数有array如何处理等。<br>你看，这个讨论顺序就是从简单的到复杂的，从一点到线，再到面，从方法论来说就是bottom-up的方法。现在的问题，我们站在一个函数的层次，看到什么呢？讲看到其他很多函数，这么函数如何interact尤其是有关联的时候，当然没有关联我们就没有必要讨论了，这里讨论的意义就是基于这些函数相互有关系。我们去explore这层关系，看编译器如何设计。<h4 id="Local-variables"><a href="#Local-variables" class="headerlink" title="Local variables"></a>Local variables</h4></li>
<li>每个函数体内的变量就是local，因此有automatic storage duration和block scope. 先说啥叫automatic storage duration?　这是说这个变量的生命长度，函数执行的时候分配空间，函数执行完毕，空间就回收了，这个变量就不存在了；再说block scope:这是说变量的存在空间只在这个函数的block内，严格的说是从定义开始到函数结束或block statements结束。这和上面的时间相对应，本来一切问题都是时空的问题，程序设计稍微有点哲学的味道。</li>
<li>Static Local variables: 和local的区别就是生命长度不在是automatic的，而是static的。所谓static storage duration就是编译器给这样的变量分配了一个永久的存储位置，让这个变量一直有效直到整个program结束。static名字取得很好，变量空间一旦分配就没打算用完就收回，因此这个空间一定和automatic storage的存储空间不一样，事实上，static存在heap上，和dynamic的内存分配放在一个区块，而automatic则是放在stack。这里也就是说编译器设计还是合理的，有些变量就是需要长期存在的，值得称赞！但需要注意的是，虽然存在时间长了，但是从这个变量往外看还是只能看到这个函数的边界，不能看到别的，因为它是local的嘛。因此，这样的变量适合用来多次调用同一个函数，不断修改里面的变量，例如：可以设置一个变量来统计函数调用的次数，那么就可以新建一个static local variable来统计。因此，使用这样的变量的物理意义，是对一个信息的计算不但依赖这一次的输入，还依赖以前的输入，因此可以认为是一个markov过程。你看，把数学的东西引入，问题看得更明白，也就容易appreciate这个语言设计的完备性！</li>
</ul>
</blockquote>
<h4 id="External-variables"><a href="#External-variables" class="headerlink" title="External variables"></a>External variables</h4><ul>
<li>external是相对于local而言的，由于local的变量总是属于某一个block，那么external则不属于任何block，任何函数，因此也叫global。external变量physically不属于任何函数，但是functionally则是属于任何函数。怎么讲？由于不偏向任何函数，所以每个函数都可以公平的使用他。这里就有点哲学意味，什么都拥有和什么都没有有时候是一回事。理解了这一点，就容易理解它的生命长度和生存空间了：<blockquote>
<ul>
<li>static storage duration:因为不属于任何函数，所以和任何函数结束与否没有关系，只和整个program结束有关系</li>
<li>file scope:还是上面的原因，不属于任何函数，因此就属于所有函数。能看到所有函数！</li>
</ul>
</blockquote>
</li>
<li>说了external的好处:可以在多个函数间传递大量的数据。再说external的不足：<blockquote>
<ul>
<li>由于谁都可以访问，谁都可以修改。这个机制就相当于广播，所以要慎用。比如，如果在一个地方修改，需要检查所有需要使用的地方是否会受到影响。例如：如果原来是int，我把他修改成float,是否有的函数就不能调用了。</li>
<li>如果external或者就是global变量被错误赋值，那么就不容易检查到底是哪一个函数干的，因为完全没有记录，所以不容易调试。</li>
<li>还有一点，用全局变量的话，由于这个参数在很多函数里直接使用，那么这个函数的独立性就变差，想要reuse这个函数，就变得困难。因此，一方面看到global是可以增加交换信息的渠道，另一方面看到global让函数不够独立，不够封闭，因为如果要交流，就得打开函数，留个接口，天然导致reusablity差。</li>
<li>关于取名。如果是local的变量，取名字就随意很多，因为函数的封闭性，但是external就不能草率，每个external就是一个通道，因此，物理意义和功能非常明确，所以名字一定要表示清楚。<br>-现在我就有问题了：哪些地方可以用external呢？我</li>
<li>这本书好就好在，能对同一个问题，从不同角度呈现给你看，这还不够，还给你举例子，不冷冰冰的push你从某个角度看，而是引诱你自然而然就从另一个角度看见了问题和冲突，很精彩！</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="如何组织一个c程序？"><a href="#如何组织一个c程序？" class="headerlink" title="如何组织一个c程序？"></a>如何组织一个c程序？</h4><ul>
<li>一般的顺序如下图：<br><img src="http://i.imgur.com/31vXXGY.png" alt=""><br>首先就是，#include库，包，然后是#define宏，因为前两个都是预处理，之后就是typedef,声明external变量，prototypes for functions,然后是main函数，最后才是各个函数的定义。</li>
<li>书上有个很好的书写规范：就是在每个函数前面用一个boxed comment,说明这个函数的用途，每个参数的物理意义，返回值的意义，一些重要说明，比如：依赖某个external变量。这些都是为方便调试和归档记录！同时写这个也是为了方便对函数独立性的判断，有可能写出来的时候，发现某些函数还是合并成一个函数比较容易，而有些函数分成两个函数比较合乎真实！下面就是个例子：在每个函数前面说明这个函数的功能。<br>　<img src="http://i.imgur.com/48Srj5G.png" alt=""></li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li>指针就是内存里保存的属于某个数据类型的数据的地址。</li>
<li>指针有什么用？<blockquote>
<ul>
<li>由于指针就是地址，那么指针就可以间接访问数据。由于是间接访问数据，在作为参数传递给函数时，虽然也是pass-by-value,但这次传递的是指针，也就是告诉了子函数这个数的家庭住址，那要修改就容易了，直接找到这个数据的家里，把这个数给修改了。因此，如果希望函数修改入口参数的值，用指针就是好办法。</li>
<li>根据自己的感受，我还看出一点：如果把所有数据看成处于同一个层次的数，那么指针就和数据不在一个层次，指针的层次要底一些，或者说更重要一些。有了指针，一样可以知道这个数的值，还可以任意修改这个数的值。或者说，指针配合pass-by-value这个机制，指针弥补了pass-by-value这个机制。由于指针层次更低，灵活性必然更强，但也更容易出错。</li>
<li>接着说pass-by-value,这个机制的问题是啥？如果是一个值，这样也没什么问题，如果是一个数组，pass-by-value就浪费空间时间了，在另一个地方复制这些数，耗时间，还占地方。这个时候，就更需要用指针，把这个数组的指针传递过去就可以，在子函数里直接修改，因此，我说指针是配合更是弥补了pass-by-value。让这个机制即可以传递数据，如果我不希望修改原来的数据，又可以传递地址，让主程序和子程序访问同一个位置的数据。这么看，指针确实灵活，但是问题就出在这儿，程序的调用的时候，入口参数就是两者之间的接口。如果入口参数用指针，这个接口就开得很深，使调用者和被调用者增加了联系，让两种不够独立，所以如果大量用指针，说明这个调用者和被调用者本身不够独立，因此这个函数是否值得单独写出来，就要再次考虑了。</li>
<li>总结一下：指针和变量不同层次，指针层次低，所以可以做更细节更精细的调整，因此更灵活，这个灵活从另一个角度看，就增加了相互的关联，相互影响的可能就增强，因此就需要谨慎使用。如果沿着这个思路往下，所有的指针是一个层次，那么指针的指针就是更底层的事物了，可以做到更精细的控制，因此这个逻辑可以一直延伸下去。</li>
<li>写到这里，我突然想到指针的方法,或者稍微严谨的说，指针的思维，是和微积分中求导数一样。求导就是得到了每个位置的变化率，也就是得到了更多的细节，因此，求导就是一种分析的方法，所谓分析，就是把一个事物掰开了，揉碎了，看仔细了。这么一比较，指针就是数据的求导；指针的指针就对应与微积分中的二阶求导。还可以依次类推！</li>
</ul>
</blockquote>
</li>
<li>上面的思路，看到一个事物的正面，就自然能想到这个事物的反面。当然，严格的说，并没有正面和反面之分，或者说当我说正面或反面，不具有感情色彩，我只是想表达一个事物天然就存在两个方面，这两个方面相生相克而已。这个思路，是学c语言的时候，或者是学任何东西时，需要有的态度。</li>
</ul>
<h4 id="pointers-as-return-value"><a href="#pointers-as-return-value" class="headerlink" title="pointers as return value"></a>pointers as return value</h4><ul>
<li>函数返回值可以是指针。如果这个指针是入口的参数的指针，就可以尽情的返回，没毛病；如果打算返回的指针是函数内分配的local指针，那就有毛病了。为什么呢？函数内分配的local指针的存在时间有限，一旦跳出函数就没有了，或者说就从stack里给清空了。</li>
<li>如果返回的指针是exteral的，或static的，也是可以的，因为这两种的存在周期和scope都保证了返回的时候依然有效。</li>
<li>看过这一小节的讨论，有必要说说写书的模式：首先我们介绍完函数的内容，包括入口函数，返回类型，等等。这是基本问题，然后我们学了指针，appreciate指针的好处和不好的地方。当引入指针的时候，就有一个问题立刻出现，指针和函数的interplay是怎样的？简单说，就是我们学东西或者写书介绍东西，总是学一个相对独立的知识，比如函数，然后再学一个高级的功能，比如指针，最后就要看指针+函数会出现什么新的情况。这就想做科研的时候，我们有了a技术，后来有了b技术，表面看a和b是独立的，其实是有关系，所以我们就需要研究a+b.而a+b就有三种可能：<blockquote>
<ul>
<li>(a+b)&lt;(a)+(b)。有必要说一下前面这个表达的意思：(a+b)表示incorporate a with b之后要考虑的情况，(a)、(b)则表示只考虑a或b的情况；不等号可以是复杂度，可以是性能，可以是任何的对比。继续说这个表达式的物理意义，就是合在一起研究的复杂度小于分开的复杂度，这说明两者的复杂度有一部分共享了所以合并了，因此放在一起总的效果就变简单了；</li>
<li>(a+b)==(a)+(b)。如果相等，意味着这两个技术确实是独立的，不相干的，因此和在一起研究就是没有意义的。你看，从方法论来看，概率中的相关的概念也可以拿来使用，数学之道，确实王道！</li>
<li>(a+b)&gt;(a)+(b)。放在一起，变得更复杂了。这是因为，两个事物本身不相互消除，而是相互排斥，也就是两个事物没有共同的东西，放在一起，为了form一个新的东西，就要比以前复杂了，因为要考虑很多edge case之类的。如果这个复杂只是某一个方面，在其他方面还是变简单的话，这个方法也是值得讨论的，而且还可以衍生出新的研究课题：如何让这个复杂度变简单。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul>
<li><p>p.254:这里有个非常有意思的话题：const＋指针关系。和前面一样的写书思路：我们有了const概念，也有了指针概念，那么const+指针有什么新的情况吗？</p>
<blockquote>
<ul>
<li><p>认识const int *p:　<del>注意现在const是放在int*之前，回想之前学习if-else中出现的dangling case时遇到的问题的处理原则，即：else是和离自己最近的没有配对的if配对。这个原则用在这里怎么配对呢？const和离自己最近的配对：所以const是修饰int *，也就是指针是不能改变的，也就是p初始指向谁，就一辈子指向谁，不能变了，但是p指向的位置中的值就可以变。</del><strong>更正</strong>，前面的理解有误。重新思考，发现自己恰好说反了。重新描述：由于const是修饰的*p,而*p表示指针p指向的值，也就是说：指针p指向的值不可修改，或者说通过指针p访问只有只读功能，不具备写的功能。虽然指向的内容不能修改，但是可以指向不同的内容，也就是可以查看多个数据的内容，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">int</span>* p</span>)</span></div><div class="line">&gt; &#123;</div><div class="line">&gt;     <span class="keyword">int</span> j;</div><div class="line">&gt;     *p=<span class="number">0</span>; <span class="comment">//wrong</span></div><div class="line">&gt;     p=&amp;j; <span class="comment">//legal</span></div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>认识int * const p:和前面的思路一样:<del>const离p最近，而int*是修饰const,所以表示指向的位置中值不变，因此指针可以指向别的位置，但就不能修改p现在指向的位置的值。</del>更正：和上面更正后的讨论一样，const这次是修饰的p,而不是*p,所以：p这个指针不可修改，也就是说p指向谁就固定不变，不能再指向别人。虽然不能指向别人，也就是指针是const，但指向的数据的内容就可读可写，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span>(<span class="params"><span class="keyword">int</span> * <span class="keyword">const</span> p</span>)</span></div><div class="line">&gt; &#123;</div><div class="line">&gt;     <span class="keyword">int</span> j;</div><div class="line">&gt;     *p=<span class="number">0</span>; <span class="comment">//legal</span></div><div class="line">&gt;     p=&amp;j; <span class="comment">//wrong</span></div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>认识const int * const p:这个就是前面两个情况的合并，没什么说的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p</span>)</span></div><div class="line">&gt; &#123;</div><div class="line">&gt;     <span class="keyword">int</span> j;</div><div class="line">&gt;     *p=<span class="number">0</span>; <span class="comment">//wrong</span></div><div class="line">&gt;     p=&amp;j; <span class="comment">//wrong</span></div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="Pointers-and-arrays"><a href="#Pointers-and-arrays" class="headerlink" title="Pointers and arrays"></a>Pointers and arrays</h3><ul>
<li>前面讨论pointer+function,现在讨论pointer+array。这个思路是对的，本来交代一个新的事物，尤其是底层的事物，那么这个事物(pointer)和以前的事物的interplay就值得研究，也就是说，由于指针是比前面交待的事物都第一个层次的事物，那么很可能和所有高级的事物都有接口，这个道理不难理解，低层次的事物复杂就复杂在这里，和高层事物总有关联。这也是为什么指针在c语言里面很重要，因为其他的事物是一个层次，指针又是另一个层次，而且是更低的层次。但是指针概念本身确实很简单，无非就是一个地址。所以这个给我的启发，就是不要从简单还是复杂这个角度看问题，而是要从这个事物的层次，在整个问题中所处的位置来决定。这么想，很多不容易理解的问题也就容易理解了，比如：指针的理解不是从他是什么来理解，而是从他在整个设计中的位置和层次来理解。我们学东西，尤其是学技术，看到很多新的东西，脑袋里默认这些都是摆在一个平面上的，没有上下之分，所以学起来就困难。为什么？因为本身事物的真相是有层次，有上下之分，是立体的存在，如果非要把立体的看成平面的，就失去了很多细节，问题就看不清楚了。这就好比，天空的云彩是有层次的，有的云的位置高，有的位置低，但如果我们只站在地上看，永远看不出来有层次，以为所有云朵都一样高，或者看太阳和月亮也一样高，就是因为我们习惯简化事物，而不是认识事物本来面貌的思维恶习导致的！</li>
</ul>
<h4 id="pointer-arithmetic"><a href="#pointer-arithmetic" class="headerlink" title="pointer arithmetic"></a>pointer arithmetic</h4><ul>
<li>指针运算，指针就是地址，根据一个地址，就可以知道相邻的其他位置。指针运算就是做加减法。这一章是将指针和array，所以讨论的指针运算也是在数组的范围内，如果超出了数组的范围，就会出现undefined behavior.<blockquote>
<ul>
<li>除了加减，还可以比大小<h4 id="using-pointer-for-array-processing"><a href="#using-pointer-for-array-processing" class="headerlink" title="using pointer for array processing"></a>using pointer for array processing</h4><h4 id="using-an-array-name-as-a-pointer"><a href="#using-an-array-name-as-a-pointer" class="headerlink" title="using an array name as a pointer"></a>using an array name as a pointer</h4></li>
</ul>
</blockquote>
</li>
<li><p>这就到了精彩之处！数组的名字为啥可以做了数组的指针？因为a[i]表示的数和*(p+i)是一样的，而且数组中的坐标运算和指针的运算也一样，所以，数组名字作为指针就可以理解了，pass数组的名字，也就是等于pass一个指针，也不用在子函数中去重新产生一个数组了，直接就在原来数组中修改，这一点也说明，数组名也可以当做指针。再仔细思考，数组这个数据结构，在c语言建立的时候，也就把地址，或者说把第一个元素的地址和数组绑定当一起了。用数组名当指针，简化了代码的书写，例如：</p>
<blockquote>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">for(p=&amp;a</span><span class="title">[</span><span class="comment">0</span><span class="title">]</span><span class="comment">;p</span>&lt;<span class="comment">&amp;a</span><span class="title">[</span><span class="comment">N</span><span class="title">]</span><span class="comment">;p</span><span class="literal">+</span><span class="literal">+</span><span class="comment">)&#123;sum</span><span class="literal">+</span><span class="comment">=*p;&#125;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>简化一下，就变成：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; for<span class="comment">(p=a;p&lt;a+N;p++)</span>&#123;sum+=*p;&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>using a pointer as an array name：这是什么意思？如下：</p>
<blockquote>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">int</span> a[<span class="built_in">N</span>],i,<span class="built_in">sum</span>=<span class="number">0</span>,*p=a;</div><div class="line">&gt; for(i=<span class="number">0</span>;i&lt;<span class="built_in">N</span>;i++)&#123;<span class="built_in">sum</span>+=p[i];&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>也就是说，既然函数名就是指针，可以用a[i]表示一个元素，同样可以用p[i]表示一个元素</p>
</blockquote>
</li>
</ul>
<h4 id="pointers-and-mutidimensional-arrays"><a href="#pointers-and-mutidimensional-arrays" class="headerlink" title="pointers and mutidimensional arrays"></a>pointers and mutidimensional arrays</h4><ul>
<li><p>遍历二维数组的第i列，如何操作？看下面例子：</p>
<blockquote>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; int a[<span class="symbol">NUM_ROWS</span>][<span class="symbol">NUM_COLS</span>],(*p)[<span class="symbol">NUM_COLS</span>],i;</div><div class="line">&gt; ...</div><div class="line">&gt; for(p=&amp;a[<span class="number">0</span>];p&lt;&amp;a[<span class="symbol">NUM_ROWS</span>];p++)</div><div class="line">&gt;   (*p)[i]=<span class="number">0</span>;//还可以表示为*(p+i)=<span class="number">0</span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p><strong>说明</strong>：由于二维数组都是按行保存的，所以首先p需要指向一个行向量，因此int  (*p)[NUM_COLS],这个定义很少见，这里又要说一下区别了，如何定义一个指针指向一个array,又如何定义一个指针数组，前者是一个指针，但指向一个array，后者是多个指针组成一个array.这两者是有很大区别的。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="selector-tag">int</span>  (*p)<span class="selector-attr">[NUM_COLS]</span>；<span class="comment">//有括号表示一个指针，但是指向一个array;</span></div><div class="line">&gt; <span class="selector-tag">int</span>  *<span class="selector-tag">p</span><span class="selector-attr">[NUM_COLS]</span>;<span class="comment">//没有括号，指针数组，定义了多个指针</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>说明：出现上面的这个区别，是因为*和[]优先级不同，具体的说，[]优先级是所有运算最高的。优先级可以参考<a href="http://c.biancheng.net/cpp/html/462.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/462.html</a></p>
</blockquote>
</li>
<li>对int a[M][N],p=a[i]表示p指向a的第i行，或者说a[i]也是一个指针。</li>
<li><p>对int a[M][N],a也是一个指针，但是不是指向第一个元素a[0][0],而是指向第一行元素a[0]。为什么呢？这个就跟编译器如何解释二维矩阵有关系了。在c编译器中，把二维的仍然看成是一维的，但是每个元素是一个一维的array,因此，二维数组的名称仍然代表第一个元素，即第一行元素，顺着这个思路继续，就是a[0]就代表第1行的第1个元素的指针。举例：</p>
<blockquote>
<p>直接的写法：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; for<span class="comment">(p=&amp;a[0];p&lt;&amp;a[NUM_ROWS];p++)</span></div><div class="line">&gt;   <span class="comment">(*p)</span>[i]=<span class="number">0</span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>利用以上特殊性质,简化：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; for<span class="comment">(p=a;p&lt;a+NUM_ROWS;p++)</span></div><div class="line">&gt;   <span class="comment">(*p)</span>[i]=<span class="number">0</span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul>
<li>这一章有个很有趣的问题：对于a[NUM_ROWS][NUM_COLS],a是代表第0行的地址，a[0]代表第0行第一个数地址，但两个值都是一样，指向a[0][0],那这两个为什么需要区别呢？<blockquote>
<ul>
<li>这个问题就是没有搞清楚指针的类型，a这个指针的类型是int(<em>)[NUM_COLS],即：指向数组的指针而a[0]则是int</em>,即：指向整数的指针，类型不相同，值一样不说明啥。这也是编译器设置了严格的类型匹配以检查错误。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="Strings-字符串"><a href="#Strings-字符串" class="headerlink" title="Strings: 字符串"></a>Strings: 字符串</h3><p>把多个char放在一起，可以用array来保存，但是不够方便。说不方便，是因为不知道多个char的长度，因此，需要明确告之使用char array的函数。</p>
<h4 id="string-literals"><a href="#string-literals" class="headerlink" title="string literals"></a>string literals</h4><ul>
<li>string literals：就是常数的string,保存在内存里的某个位置，但不能修改常数string。</li>
<li>如何保存？关键是如何方便表达长度？把长度embedded into the string. 这就得说c语言的美妙之处了！在每个string末尾添加一个小尾巴表示结束，这个尾巴就用\0，也就是全0的内容来表示一个NULL。这个做法，有点像编码，用全0表示没有，所以就是一个结尾。</li>
<li>从编译器看string,是啥？<blockquote>
<ul>
<li>string由于保存在array中，所以编译器看的话，仍然是一个指针，或者就是string第一个字符的地址。因此，如果用printf(“abc”),那么传递给printf()的只是这个string的地址。这个规则和前文将array+pointer是一致的。</li>
<li>所以，下面的例子也是成立的：<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; char *p<span class="comment">;</span></div><div class="line">&gt; p=<span class="string">"abc"</span><span class="comment">;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="string-variables"><a href="#string-variables" class="headerlink" title="string variables"></a>string variables</h4><ul>
<li><p>保存方式和前文string literals一样，都是在末尾加NULL.因此，如果要保存N长的string,那么需要的数组长度就是N+1，例如：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> LEN 80</span></div><div class="line">&gt;<span class="keyword">char</span> str[LEN+<span class="number">1</span>];<span class="comment">//长度+1</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>初始化：可以定义的时候顺便初始化。例如：</p>
<blockquote>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="keyword">char</span> <span class="keyword">str</span>[<span class="number">8</span>]=<span class="string">"June 14"</span>;<span class="comment">//长度+1</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面就是长度8的array保存了7个char字符，最后一个字符是\0.值得说明的是，这里只是要求array长度比初始化的string长度多1个即可，但是多2个、3个也是合法合理的，例如：</p>
<blockquote>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="keyword">char</span> <span class="keyword">str</span>[<span class="number">9</span>]=<span class="string">"June 14"</span>;<span class="comment">//长度+2</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>那多余的位置保存的是什么呢？这个还是看编译器咋个操作了，书上说编译器还是会初始化没有数据的位置，添加\0，这个规则也和前文用0初始化数组的做法一致。</p>
</li>
<li><p>现在考虑一个极限情况，考虑极限情况才看得出问题，而不是在正常情况，这个是思维的转变，正常情况大多可以handle,要比较好坏还得看极限情况。这个极限情况就是：如果数组长度和string的字符个数一样多或者还少，怎么办？由于是顺序保存数据，没有空间保存\0，就得程序员负责，编译器应该会报错或warning。由于这个原因，我们初始话数组的时候一定要注意是否留有“余地”。除了笨拙的去人工计算，还有一个更好的办法，让编译器来帮忙数个数，例如：</p>
<blockquote>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="keyword">char</span> <span class="keyword">str</span>[]=<span class="string">"June 14"</span>;<span class="comment">//</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>看到[]，编译器就自动去计算长度，同时长度+1，把最后位置设为\0。需要注意的是，一旦设置好长度，就固定不变了，最长就这么长了，所以也是有缺陷的。总之，和c++比较，就显得不灵活也很琐碎！没办法，谁叫c是偏低层语言呢！</p>
</li>
<li><p>character arrays vs character pointers:</p>
<blockquote>
<p>比较下面的区别：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="keyword">char</span> <span class="keyword">date</span>[]=<span class="string">"June 14"</span>;</div><div class="line">&gt;<span class="keyword">char</span> *<span class="keyword">date</span>=<span class="string">"June 14"</span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>由于数组名等效数组的地址，因此这两个如果传递给函数，都是等效的。那有区别吗？没区别的话，这两个是否interchangeably?答案是否定的：</p>
<ul>
<li>区别1：常数vs变量：在array的版本中，后面是一个string variables,可以任意修改内容；在指针版本只能怪，后面则是一个string literals,前面说过，不能修改内容。</li>
<li>区别2：在array版本中，date是数组名，不能更改，也就是说date是一个指针，但这个指针只能永久的指向后面这个数组；在指针的版本中，由于天然是指针，那么就可以指向其他的string。</li>
<li>总结：上面两个对比，本质上就是：array的版本相当于是定义了一个const指针，但内容可变，即：<del>const char* date；</del>更正：int<em> const date; 指针版本则相当于定义了一个const内容，但指针可变,即：~~char\</em> const date;~~更正：const int* date; 这个就和上一章将const+指针的讨论一致！</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="Reading-and-writing-strings"><a href="#Reading-and-writing-strings" class="headerlink" title="Reading and writing strings"></a>Reading and writing strings</h4><p>写string:</p>
<ul>
<li>用printf()打印string，需用\%s说明。打印的过程是这样的：printf()收到string的地址，然后发现是要\%s的打印，因此就一个一个打印，until遇到\0,如果没遇到\0,就一直打印，知道遇到\0。</li>
<li>编译器除了支持这种盲打的方法，还支持指定数量的打印，例如：printf(“\%.6s\n”,str);就指定打印前面6个。</li>
<li>printf还可以规定打印的区间的长度，用\%ms,例如：\%10s,表示把这个string打印在10为长度的区间里，如果打印的string的长度小于10,右对齐，让左边留白；如果打印长度大于10,就全部打印，不会truncate。把上面两个结合起来，就是\%10.6s!</li>
<li>除了用printf外，还可以用专用的puts(str)打印。</li>
</ul>
<p>读string:</p>
<ul>
<li>scanf(“\%s”,str);注意：str前面不需要&amp;,因为str是数组名，天生就包含地址信息。</li>
<li>gets()（略）</li>
</ul>
<h4 id="Accessing-the-characters-in-a-string"><a href="#Accessing-the-characters-in-a-string" class="headerlink" title="Accessing the characters in a string"></a>Accessing the characters in a string</h4><p>书上举了两个种方法：<br>第一种：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> count_space(<span class="keyword">const</span> <span class="built_in">char</span> s[])&#123;</div><div class="line">  <span class="built_in">int</span> count=<span class="number">0</span>,i;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;s[i]!='\<span class="number">0</span>';i++)<span class="meta">&#123;...&#125;</span></div><div class="line">  <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> count_space(<span class="keyword">const</span> <span class="built_in">char</span> *s)&#123;</div><div class="line">  <span class="built_in">int</span> count=<span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(;*s!='\<span class="number">0</span>';s++)<span class="meta">&#123;...&#125;</span></div><div class="line">  <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>两个方法效果一样，但是做法有别。第一种，传递的是数组名，数组名就是指针；第二种，直接传递指针。传递指针显得代码简洁，因为不需要再定义一个变量i在array寻址,这是因为数组名虽然代表指针，但这个指针只能指向array第一个位置，所以这个指针只是一个const指针，所以需要一个i变量作为偏移量；传递指针就可以修改这个指针。</li>
<li>另外，两个参数都在前面加了const关键字，对array而言，表示不能修改数组内容，对指针而言，表示不能修改指针指向的内容，这和前文讨论一致，但仍可以修改指针。</li>
<li>第二种情况，注意入口仍然是值传递，s是拷贝的值，瑞士修改了s值，但不会改变调用函数时给s赋值的指针的指向，所以这个方法就和灵活</li>
</ul>
<h4 id="Using-the-C-String-library"><a href="#Using-the-C-String-library" class="headerlink" title="Using the C String library"></a>Using the C String library</h4><p>字符串数组的操作，一些常用的定义在<string.h>中。</string.h></p>
<ul>
<li><p>strcpy():拷贝</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>*s1,<span class="keyword">const</span> <span class="keyword">char</span>*s2)</span></span>;<span class="comment">//prototype</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>字符串不能直接赋值，必须通过拷贝实现，和c++比起来，确实c就是机器语言啊。上面的原型表示把s2拷贝到s1中，而且s2是const的类型，过程是这样的：通过s2找到存储string的位置，然后一个字符一个字符的拷贝到s1指向的array位置，直到遇到\0,注意：\0也会拷贝。正常情况下，s1是可以容纳这么多数据，极限情况呢，如果s1指的位置长度不够，那么编译器怎么处理呢？书上说编译器会继续拷贝，直到遇到\0,也就是不会检查s1的边界是否到了，所以就可能导致s1后面的数据被覆盖，出现undefined behavior。因此，编译器又相出一个方法，strncpy(str1,str2,sizeof(str1));限定长度来拷贝。细节不表了！</p>
</li>
<li><p>strlen():长度</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>*s);<span class="comment">//prototype</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>size_t是c语言定义的一个typedef名称，代表unsigned整数，注意没说是int,可能是short,可能是long,也就是说size_t屏蔽了细节，提高了portability. 例如：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; len=<span class="built_in">strlen</span>(<span class="string">"abc"</span>);<span class="comment">//len=3</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>我们知道”abc”array的长度是4,但这里返回3,因此说明strlen只返回string的长度，而不是array长度，这个也make sense.</p>
</li>
<li><p>strcat():两两连接</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*s1,<span class="keyword">const</span> <span class="keyword">char</span>*s2)</span></span>;<span class="comment">//prototype</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>说明：把s2的内容拷贝到s1后面，然后返回s1的指针。同样的，如果拷贝后，长度超过了array长度，就会undefined behavior,因此又诞生了一个命令增加了长度的控制，即：strncat().细节不表！</p>
</li>
<li><p>strcmp():两两比较</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*s1,<span class="keyword">const</span> <span class="keyword">char</span>*s2)</span></span>;<span class="comment">//prototype</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>说明：strcmp compares string based on their lexicographic ordering.如果不是字母，则比较ASCII code的值。如果返回值==0，说明相等；如果返回值<0,说明str1<str2;如果返回值>0,说明str1&gt;str2.</0,说明str1<str2;如果返回值></p>
</li>
</ul>
<h4 id="Arrays-of-Strings"><a href="#Arrays-of-Strings" class="headerlink" title="Arrays of Strings"></a>Arrays of Strings</h4><p>这个思路我们很熟悉，我们知道array了，也刚介绍了string,那array+string有什么新鲜的吗？还真有！</p>
<ul>
<li><p>二维数组：</p>
<blockquote>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; char planets<span class="string">[]</span><span class="string">[8]</span>=&#123;<span class="string">"Mercury"</span>,<span class="string">"Venus"</span>,<span class="string">"Earth"</span>,<span class="string">"Mars"</span>&#125;;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面的例子用二维数组表示，这种表示方法，或者是看待string array的方法，由于采用二维数组，所以列数就需要保证可以存最长的string,也就是保证worst case可以正常工作，这可以看成是一种静态的表示方法，由于值考虑worst case,所以大部分情况很浪费空间。</p>
</li>
<li><p>指针数组：</p>
<blockquote>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; char *planets<span class="string">[]</span>=&#123;<span class="string">"Mercury"</span>,<span class="string">"Venus"</span>,<span class="string">"Earth"</span>,<span class="string">"Mars"</span>&#125;;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>所谓指针数值，就是数组的成员都是指针，上面就定义了一个指针数组，每个指针指向一个string literals.这里就节省很多空间，当然需要额外的空间来保存这些指针。如下图，对比了两种保存方式：<br><img src="http://i.imgur.com/AsG2R2h.png" alt=""><br><img src="http://i.imgur.com/4QCMKxq.png" alt=""></p>
</li>
</ul>
<h3 id="The-preprocessor"><a href="#The-preprocessor" class="headerlink" title="The preprocessor"></a>The preprocessor</h3><p>预处理器就是处理#开头的语句，通常在程序开头的位置，通常就是替换，知道的c语言知识较少，功能也比compiler简单很多。</p>
<h4 id="Macro-definition"><a href="#Macro-definition" class="headerlink" title="Macro definition"></a>Macro definition</h4><ul>
<li><p>simple macros:简单的宏，没有参数。例如：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> LEN 5</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面和下面都是简单宏，</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> MEM_ERR <span class="meta-string">"Error:not enough memory"</span></span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>使用宏有很啥优点呢？</p>
<blockquote>
<ul>
<li>easier to read the program: 就是赋予一些常数本身有的物理意义，不然突然出现在程序中，看起来容易晕。</li>
<li>easier to modify the program: 容易修改，有些常数可能在程序中多次使用，如果需要修改这个常数，就要查找该参数出现的所有位置，然后替换。但保不齐，等于这个常数的并不是都需要修改。这个时候，如果用宏，相当于把相同的数放在一个篮子里，方便读，方便改</li>
<li><p>renaming types:如下。但书上说修改类型，不如typedef高级！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> BOOL int</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>控制conditional compilation。条件编译.</p>
</li>
</ul>
</blockquote>
</li>
<li><p>Parameterized Macros:带参数的宏，有点像函数。也就是说一些简单的函数可以在macro中定义，但为什么这么干呢？有这个必要吗？</p>
<blockquote>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; #<span class="keyword">define</span> identifier(<span class="keyword">x</span><span class="number">1</span>,<span class="keyword">x</span><span class="number">2</span>,...xn) replacement-list</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<ul>
<li>上面的identifier和后面的参数前的左括号间不能留空格，否则预编译器会认为是一个简单的宏，而不是一个带参数的宏。例如下边就是一个带参数宏：  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define MAX(<span class="name">x</span>,y) ((<span class="name">x</span>)&gt;(<span class="name">y</span>)?(<span class="name">x</span>):(<span class="name">y</span>))</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>下面由于多了一个空格，就是简单宏。所谓简单宏，就是编译器没有这么大能耐区分是故意放的空格还是不小心放的空格，再次说明预编译器简单。</p>
<pre><code><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define MAX (<span class="name">x</span>,y) ((<span class="name">x</span>)&gt;(<span class="name">y</span>)?(<span class="name">x</span>):(<span class="name">y</span>))</div></pre></td></tr></table></figure>
</code></pre><p>为什么每个参数都加括号？我估计也是因为预编译器傻，怕不小心就认错。再举例：</p>
<pre><code><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define MAX(<span class="name">x</span>,y) ((<span class="name">x</span>)&gt;(<span class="name">y</span>)?(<span class="name">x</span>):(<span class="name">y</span>))</div><div class="line">i=MAX(<span class="name">j+k</span>,m-n)<span class="comment">;</span></div></pre></td></tr></table></figure>
</code></pre><p>上面的代码，经过宏替换就变成了下面：</p>
<pre><code><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i=((<span class="name">j+k</span>)&gt;(<span class="name">m-n</span>)?(<span class="name">j+k</span>):(<span class="name">m-n</span>))<span class="comment">;</span></div></pre></td></tr></table></figure>
</code></pre><p>现在就能看出来，为什么每个参数都需要加括号了，因为预处理器不计算，不evaluate,直接把参数替换，所以如果参数不是一个参数，而是一个表达式的时候，就有必要用括号来表示运算顺序了！这么看，宏真有点一无是处！也不是宏一无是处，而是预编译器一无是处。我可以用inline函数来实现带参数的宏！两种的区别是啥？</p>
</li>
<li><p>带参数宏的优点：</p>
<blockquote>
<ul>
<li>速度快，因为不用调用函数，而是直接替换成函数内容。函数调用的时候，是从当前层次进入下一个层次，因此需要保存现场，进入下一个层次，然后计算，然后返回恢复现场，因此，函数调用就慢，而宏，就直接把子函数内嵌到主函数中。这样快倒是快了，但是问题也很严重：因为把有层次的东西给扁平化，独立的事物给搅和在一起。这从系统设计来讲，是一场灾难！</li>
<li>marcos are generic.怎么理解？带参数宏和函数定义的区别，就是不用类型说明，无论是入口参数还是返回值，都不需要指定类型。从这点出发，意味着宏函数可以多种类型都可以调用。比如，上面的MAX,用int,long,float,double都是可以的。</li>
</ul>
</blockquote>
</li>
<li><p>参数宏的缺点：</p>
<blockquote>
<ul>
<li>经过预编译后的代码很长很长！这个还是因为宏的操作只有替换，没有evaluate这个过程导致的，比如：  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n=MAX(<span class="name">i</span>,MAX(<span class="name">j</span>,k))<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>  那么替换之后，就长这样：</p>
<pre><code><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n=((<span class="name">i</span>)&gt;(((<span class="name">j</span>)&gt;(<span class="name">k</span>)?(<span class="name">j</span>):(<span class="name">k</span>)))?(<span class="name">i</span>):(((<span class="name">j</span>)&gt;(<span class="name">k</span>)?(<span class="name">j</span>):(<span class="name">k</span>))))<span class="comment">;</span></div></pre></td></tr></table></figure>

这还是嵌套一次，如果多次，那代码长度就指数增加。因此，这个办法确实很笨，简单替换，不能用来干复杂的事情，而且，会多次计算，时间上也划不来。
</code></pre><blockquote>
<ul>
<li>不检查类型，也不转换类型，出错自己负责。</li>
<li>不能用指针：比如对普通函数，可以用pointer-to-function,但宏在预处理后就消失了，所以不能指向宏，因为宏压根就不是函数，当然不能指向他了。</li>
<li>宏由于在入口的时候不evaluate,而是直接代替，那么代替后，每使用一次，就要evaluate一次。例如：  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">n</span>=MAX(i++，j);</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>  预处理展开后，就变成：</p>
<pre><code><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n=((<span class="name">i++</span>)&gt;(<span class="name">j</span>)?(<span class="name">i++</span>):(<span class="name">j</span>))<span class="comment">;</span></div></pre></td></tr></table></figure>
</code></pre><p>你看，i++就执行了两次，而本意只需要执行一次。</p>
</li>
<li>宏定义后，在整个file都有效，也就是scope是file scope. 除非，遇到#undef identifier,也就是说，这据代码后就不替换了。</li>
</ul>
<h4 id="Conditional-compilation"><a href="#Conditional-compilation" class="headerlink" title="Conditional compilation"></a>Conditional compilation</h4><p>这个是调试用的一些tricks，比较有意思，可惜以前没留意。</p>
<ul>
<li>#if and #endif<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></div><div class="line">...</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"value of i:%d\n"</span>,i);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"value of j:%d\n"</span>,j);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>首先定义一个常量宏，然后用#if 宏…#endif来把调试用代码和功能代码区分，如果要调试，就把宏的值改成1，这段调试代码就会参与编译；如果不需要调试，把宏值改成0，这段代码就会被预处理器给删除。所以，这个功能，说明预处理器既可以插入替换代码，还可以删除代码，总之，预处理器会修改源码。</p>
<ul>
<li><p>defined operator<br>可以用这个关键字来检查某个宏是否已经定义过，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG)<span class="comment">//还可写成#if defined DEBUG</span></span></div><div class="line">...</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>#ifdef and #ifndef<br>#ifdef 和上面#if defined功能一样，也是检查是否定义了某个宏； #ifndef检查是否没定义，如果没定义，还可以接着定义</p>
</li>
<li><p>#elif and #else<br>宏的操作语句，确实方便了调试，这几句就是用在选择语句中，但这个是宏定义中语句，不是函数的语句，这些都是在预编译的时候就给替换了或删除了。但是执行代码的方式和if-else 一样。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> expr1</span></div><div class="line">...</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> expr2</span></div><div class="line">...</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span> expre3</span></div><div class="line">...</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>用条件编译的好处是啥？</p>
<blockquote>
<ul>
<li>可移植性:根据不同的系统或机器或编译器，做匹配</li>
<li>这一点更有用:可以把某段程序给注释掉，通过下面的方法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line"><span class="comment">//需要注释的代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
<li><p>Q&amp;A<br>问：p345看到一个有趣的问题：如果用刚介绍的用#if来给注释掉某段程序，为什么这段程序有错还会报呢？<br>答：这是因为这段程序中如果有comments，即：/*…*/,如果没配对好，就会报错。这是因为语法检查是在预编译之前完成，这个错误是有语法检查发现的，而不是编译发现的。通过这个问题，我们对c的整个编译更了解了：先语法检查，然后预编译，最后编译。</p>
</li>
</ul>
<h3 id="Writing-large-programs"><a href="#Writing-large-programs" class="headerlink" title="Writing large programs"></a>Writing large programs</h3><h4 id="Source-files"><a href="#Source-files" class="headerlink" title="Source files"></a>Source files</h4><p>大型程序，就需要把功能函数分开写，分开写的原因是方便调试，方便阅读，而且由于分割清楚，也说明对问题的了解清楚，因此分开写对复杂问题的解决之道。函数就分开在不同的源文件里定义和实现。</p>
<h4 id="Header-files"><a href="#Header-files" class="headerlink" title="Header files"></a>Header files</h4><p>源文件解决了分开的问题，但是分开的程序最终是需要combine成一个整体的。如何combine呢？c语言就是利用头文件这个方法来combine,也就是我们熟悉的#include “”来把不同函数的定义合并在一起，方便使用。那讲到#include就有两种方式了：</p>
<blockquote>
<p>#include<filename>:查找库文件所在目录directory</filename></p>
<p>#include”filename”:查找用户当前所在的directory</p>
</blockquote>
<ul>
<li>sharing macro and type definition:<br>可以把宏的定义和typedef定义放在头文件里，这样做的好处是：可能有多个函数会使用这些定义，那么就可以广播给所有的函数，不用每个函数单独写这些内容，这就是统一管理的好处，即：统一管理，方便读；第二个好处，那就是方便修改，如果需要修改一个定义，只需要修改头文件，不需要修改源文件，因为头文件只有一个，而源文件可能多个。能这么做的本质是看清了一些参数和功能是独立的这个特点，而且由于参数可以share给多个函数，因此函数和参数定义就不在一个层次了。</li>
<li>sharing Function prototype：<br>如果一组函数已经编写好了，在其他函数中如何使用这些函数呢？用头文件的方法，把这些函数的声明放在单独的.h头文件中，然后被这些函数所在的.c文件包含，同时被使用这些函数的文件包含即可！</li>
<li><p>sharing variable declarations：<br>这里说明一下声明和定义的区别，声明只是告诉编译器我接下来可能会需要使用这个函数或数据，把数据的类型和名字告诉你，但不着急替我分配空间来产生这么个数据，只是一个通知；定义则不同，不但告诉你这些信息，还需要马上给我产生一个这样的。在c语言中，为了区分声明还是定义一个变量，也有方法：我们知道函数原型就是声明，而一个变量如何保证是声明呢？由于需要单独定义的变量能被多个源文件使用，因此这类变量都应该有file scope，因此天然就是external变量，因此用：extern 来表示声明即可！例如：</p>
<blockquote>
<ul>
<li>extern int i;//声明int,但不分配内存</li>
<li>extern int a[];//由于不分配内存，所有没必要告诉编译器数组的大小。</li>
</ul>
</blockquote>
<p>变量可以多次声明，但是不能多次定义，重复定义，编译器会报错。所以我们只在一个源文件定义一次，在头文件中声明一次，用extern关键字来声明，这样其他源文件中就可以包含这个头文件，使这个变量声明多次，但定义只有一次。简单说，就是:在头文件中只能声明，因为头文件需要被多次包含的；在源文件中才能定义，因为只定义一次。例如：</p>
<blockquote>
<p>header.h声明一个变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">extern</span> <span class="keyword">int</span> global_variable;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>file1.c定义并修改了这个变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"header.h"</span></span></div><div class="line">&gt;<span class="keyword">int</span> global_variable = <span class="number">37</span>;</div><div class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">increment</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">return</span> global_variable++;</div><div class="line">&gt;&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>file2.c则使用了这个变量：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"header.h"</span></span></div><div class="line">&gt;<span class="keyword">void</span> use_it(<span class="keyword">void</span>)</div><div class="line">&gt;&#123;</div><div class="line">&gt;  printf(<span class="string">"Global variable: %d\n"</span>, global_variable++);</div><div class="line">&gt;&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Nested includes:嵌套的include<br>说白了，就是一个头文件中使用的函数或宏或类型或变量可能在其他头文件中声明的，因此需要在头文件中继续包含其他的头文件。这种包含，就给我们展现出一个有层次的结构</p>
</li>
<li><p>Protecting header files<br>由于运行嵌套的includs，有可能一个头文件被一个源文件两次包含，如下图：<br><img src="http://i.imgur.com/ht3wrLU.png" alt=""><br>由于允许嵌套包含，经过不同路径，一个源文件可能包含同一个头文件多次。如果只是声明，本没有啥问题，因为编译器对多次声明没有意见，但是对typedef就不能了，类型定义，可能会分配内存，因为从名字看就是定义嘛，为解决这个问题，我们继续用宏里面的条件编译。把每个头文件的开头和结尾添加保护，如下：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; ifndef BOOLEAN_H</div><div class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> BOOLEAN_H</span></div><div class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line">&gt; <span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</div><div class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>这样做的好处是，即使多次包含，但值编译一次，保证不重复编译。</p>
<h4 id="Building-a-multiple-file-program"><a href="#Building-a-multiple-file-program" class="headerlink" title="Building a multiple-file program"></a>Building a multiple-file program</h4><p>大型程序，往往有多个源文件和多个头文件，源文件需要分别编译，头文件不用单独编译，而是在源文件编译时同时编译包含的头文件；单独编译每个源文件得到object code,目标代码，然后用linker把所有目标代码链接成一个可执行文件.exe.</p>
<h4 id="Q-amp-A："><a href="#Q-amp-A：" class="headerlink" title="Q&amp;A："></a>Q&amp;A：</h4><p>问：由于每个源文件都需要一个对应的头文件来做声明，这样就有很多头文件，不方便管理。可以把所有的声明放在一个大的头文件中统一管理呢？<br>答：可以肯定是可以。但这样做，需要考虑后果。第一个后果，如果有很多函数，那么每次修改函数，都要去大的头文件修改对应的声明，查找就比较费事了，因为把很多不相关的声明放在一起，调试起来也比较晕；第二个后果是，由于所有声明放在一起，那么每次修改一点，都要recompile所有文件，但如果分开放，那么只需要recompile部分和这个头文件有关的代码。</p>
</li>
</ul>
<h3 id="Structures-Unions-and-Enumerations"><a href="#Structures-Unions-and-Enumerations" class="headerlink" title="Structures, Unions, and Enumerations"></a>Structures, Unions, and Enumerations</h3><p>介绍了数据结构、函数，程序。现在来到高级内容，数据结构不是简单的数据，而是复合的数据结构。有点面向对象的意思了。</p>
<h4 id="Structure-variables"><a href="#Structure-variables" class="headerlink" title="Structure variables:"></a>Structure variables:</h4><p>结构体和array都可以保存多个元素，区别是：结构体可以保存的元素类型可以不同，而且每个元素有自己的名字，而array值可以保存同一个元素，而且每个元素没有名字，只有地址。</p>
<ul>
<li><p>声明一个Structure:</p>
<blockquote>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; struct&#123;</div><div class="line">&gt; <span class="built_in">int</span> <span class="keyword">number</span></div><div class="line">&gt; <span class="built_in">char</span> <span class="keyword">name</span>[NAME_LEN+<span class="number">1</span>];</div><div class="line">&gt; <span class="built_in">int</span> on_hand;</div><div class="line">&gt;&#125; part1,part2;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>注意1：struct{}整个这一大块就是一个类型，不过是自定义的，和我们前面看到的int,char等一样，后面的part1,part2表示定义两个这个类型的变量。<br>注意2：里面的变量都只有block scope,即：只在这个struct里面有效，和外面的不相关。</p>
</li>
<li>operations on struct:<br>书上说了两种常见的方式：<blockquote>
<ul>
<li>点运算符，例如：part1.number=257；part1.on_hand++;\</li>
<li>赋值：part2=part1;就是把part1中对应的位置赋值给part2,这个方法在array中就不能这么用。所以，很多人如果对array进行赋值，就做一个dummy的struct，只包含一个数组元素，这样就可以利用struct的特点对array赋值。从这点，也可以看出，struct更灵活，编译器对它支持更好，代价应该就是更慢一些。</li>
</ul>
</blockquote>
</li>
<li><p>Structure types:<br>上面的例子只是定义了一个struct,但没有类型名字。part1只在一个变量而不是类型的名字。有两种方式给struct类型命名：</p>
<blockquote>
<ul>
<li>structure tag:<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">part</span></span> &#123;<span class="comment">//struct part就是类型名</span></div><div class="line">&gt; <span class="keyword">int</span> number</div><div class="line">&gt; <span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</div><div class="line">&gt; <span class="keyword">int</span> on_hand;</div><div class="line">&gt;&#125;;<span class="comment">//末尾的“；”必须有</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>有了类型名后，就可以用这个类型来定义新的变量：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">part</span> <span class="title">part1</span>,<span class="title">part2</span>;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>注意：关键字struct不能omit，因为类型名是struct part,不是part：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="quote">&gt; part part1,part2;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
<ul>
<li>用typedef取名<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">&gt; <span class="keyword">int</span> number</div><div class="line">&gt; <span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</div><div class="line">&gt; <span class="keyword">int</span> on_hand;</div><div class="line">&gt;&#125; Part;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：现在的类型名就是Part,而不是struct Part,和前一种方式不同。下面才是正确的使用：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="quote">&gt; part part1,part2;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Structures as arguments and return value<br>用struct作为函数的入口参数或返回值，都是struct有多大，都pass-by-value,这点和array的处理也不同。如果struct太大，这样就很慢。因此，如果有可能，尽量用pointer-to-structure来办。</p>
</li>
<li><p>Nested Arrays and Structures<br>嵌套的structure,就是说一个structure的元素仍然是一个structure,相等于你打开一个盒子，盒子里还有一个盒子。这只是现象，这么做的原因呢？例如：</p>
<blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">person_name</span></span>&#123;</div><div class="line">&gt;  <span class="keyword">char</span> first[FIRST_NAME_LEN+<span class="number">1</span>];</div><div class="line">&gt;  <span class="keyword">char</span> last[LAST_NAME_LEN+<span class="number">1</span>];    </div><div class="line">&gt;&#125;;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>然后这个名字又包含在另一个struct里：</p>
<blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span>&#123;</div><div class="line">&gt;  <span class="class"><span class="keyword">struct</span> <span class="title">person_name</span></span> name;</div><div class="line">&gt;  <span class="keyword">int</span> id,age;</div><div class="line">&gt;  <span class="keyword">char</span> sex;</div><div class="line">&gt;&#125; student1,student2;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>把关联度大的数据绑定成一个struct,名字中的两个元素就关联很密切，然后一个学生除了名字，还有其他属性，也就是说名字这个属性和其他属性是平行的，并列的，或者按照我喜欢的说法是处在一个世界的，而名字中的姓和名和id,age处在不同的世界，或者说，名和姓是更底层的世界，更细节的描述，不能够和id,age平起平坐。<br>structure+array可以想到什么？这是两个独立的概念，也就是说struct中可以包含array作为元素；array的元素也可以是struct。例如：</p>
<blockquote>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">part</span> <span class="title">inventory</span>[100];</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h4><p>和struct定义很像，例如：</p>
<blockquote>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">union</span> <span class="title">part</span> &#123;</span></div><div class="line">&gt; int i;</div><div class="line">&gt; double d;</div><div class="line">&gt;&#125; u;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>和struct不同的是内存占用，struct的所有元素都要占用空间，总的空间=所有元素分别占的空间之和；union则是总的空间=占空间最大的元素的空间。即：一个是空间求和，一个是空间求最值。<br>使用union的两个好处：</p>
<ul>
<li>省空间。由于union中元素每次只有一个是有意义的，写入一个，之前的被覆盖了，因此，如果一个struct中的数据不需要同时有效，就可以考虑用union</li>
<li><p>建立一个mixed data structure:所谓mixed,是相对array中数据类型必须一致来说的。例如，我们需要一个数据是既有int,又有double,那么用union就可以容易搞定，例如：</p>
<blockquote>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; typedef <span class="class"><span class="keyword">union</span>&#123;</span></div><div class="line">&gt; int i;</div><div class="line">&gt; double d;</div><div class="line">&gt;&#125; Number;</div><div class="line">&gt; Number number_array[<span class="number">1000</span>];</div><div class="line">&gt;...</div><div class="line">&gt;number_array[<span class="number">0</span>].i=<span class="number">5</span>;</div><div class="line">&gt;number_array[<span class="number">0</span>].d=<span class="number">8.395</span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>我们完全可以随心所欲，定义什么时候出现int,什么时候出现double，但这样的一个mixed结构有什么用呢？</p>
</li>
<li>union的不足：<br>union的问题是不知道当前在union中有效的是哪个数据。因为没有记录可查，为了解决这个问题，可以把union 嵌入一个struct中，然后用一个tag来记录最近写入union中的是哪个数。例如：<blockquote>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;typedef <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  &gt;int kind;<span class="regexp">//tag</span></div><div class="line">  &gt;<span class="class"><span class="keyword">union</span> &#123;</span></div><div class="line">  &gt;  int i;</div><div class="line">  &gt;  double d;</div><div class="line">  &gt;&#125;u;</div><div class="line">  &gt;&#125; Number;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="Enumerations-枚举"><a href="#Enumerations-枚举" class="headerlink" title="Enumerations:枚举"></a>Enumerations:枚举</h4><p>对于有限的状态或联系紧密的一组元素，可以用枚举类型，例如：</p>
<blockquote>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="class"><span class="keyword">enum</span> &#123;<span class="title">CLUBS</span>,<span class="title">DIAMONDS</span>,<span class="title">HEARTS</span>,<span class="title">SPADES</span>&#125; <span class="title">s1</span>,<span class="title">s2</span>;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面就是有四个元素的一个枚举，这个定义的方式和struct/union很类似。所以下面的也是可以的：</p>
<blockquote>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">enum</span> <span class="title">suit</span> &#123;<span class="title">CLUBS</span>,<span class="title">DIAMONDS</span>,<span class="title">HEARTS</span>,<span class="title">SPADES</span>&#125;;</span></div><div class="line">&gt; <span class="class"><span class="keyword">enum</span> <span class="title">suit</span> <span class="title">s1</span>,<span class="title">s2</span>;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>还可以用typedef来命名：</p>
<blockquote>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; typedef <span class="class"><span class="keyword">enum</span>  &#123;<span class="title">CLUBS</span>,<span class="title">DIAMONDS</span>,<span class="title">HEARTS</span>,<span class="title">SPADES</span>&#125; <span class="title">suit</span>;</span></div><div class="line">&gt; suit s1,s2;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>从人的角度看，这个就是一堆有意义的常数，从编译器，也是这么看，每个元素都有一个int对应。如果没给枚举类型的元素赋值，编译器就默认赋值0,1,2,3…<br>当然也可以赋值，例如：</p>
<blockquote>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; enum suit &#123;CLUBS=<span class="number">4</span>,DIAMONDS=<span class="number">10</span>,HEARTS=<span class="number">3</span>,SPADES=<span class="number">9</span>&#125;;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>枚举把所有元素用宏定义在功能上是一样的，但用enum把相关的联系紧密的常数放在一起，更容易用，而且enum是可以编译的，因此，里面的元素就有scope的区别，而且可以参与计算；宏则会在预编译的时候被后面的数给替换掉，不如enum灵活。</p>
<h4 id="Q-amp-A：-1"><a href="#Q-amp-A：-1" class="headerlink" title="Q&amp;A："></a>Q&amp;A：</h4><p>问：sizeof(struct)为什么得到的size比实际的bytes多呢？<br>答：这是一个好问题。因为struct中的数据多是异构的，那么这么数据的空间之和就很可能不是4的倍数，但struct开始的地址又必须是4的倍数（因为要32bit刚好4个字节）,因此不足4的倍数，就凑齐4的倍数作为sizeof()返回值，所以可能在struct末尾留有一些hole不能保存数据。</p>
<h3 id="Advanced-Uses-of-Pointers"><a href="#Advanced-Uses-of-Pointers" class="headerlink" title="Advanced Uses of Pointers"></a>Advanced Uses of Pointers</h3><p>终于来到指针高级话题：动态内存分配+函数指针。</p>
<h4 id="Dynamic-storage-allocation"><a href="#Dynamic-storage-allocation" class="headerlink" title="Dynamic storage allocation"></a>Dynamic storage allocation</h4><p>所谓动态存储：是指内存在程序执行的时候分配和回收。这个概念提出是相对静态存储，即：内存在编译的时候分配好，程序执行完后自动释放。<br>c语言支持三种动态分配函数：这个topic前面有详细讨论</p>
<ul>
<li>malloc: m开头，表示和memory打交道，比较low level,所以是按照bytes数量来分配，且不会初始化；</li>
<li>calloc:c开头，contiguous表示连续，这个连续是array连续数据的意思，所以是从数据结构的角度分配，因此按照array元素数量分配，告诉编译器元素个数以及每个元素的size，并初始化为0；</li>
<li>realloc: re表示resize,resize的功能。</li>
</ul>
<h4 id="Dynamically-allocated-string"><a href="#Dynamically-allocated-string" class="headerlink" title="Dynamically allocated string"></a>Dynamically allocated string</h4><ul>
<li><p>using malloc to allocate memory for a string,因为string每个字符就占用一个byte，所以用malloc天然适合动态分配string的空间<br>语法：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>void*表示指向任意类型的指针，可以赋值给任何指针类型，例如：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">char</span>* p=<span class="built_in">malloc</span>(n+<span class="number">1</span>);<span class="comment">//n为string长度，+1是为了放\0</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>但习惯上为啥很多书上都要在前面加一个强制类型转换：</p>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; char* p=(<span class="name">char*</span>)malloc(<span class="name">n+1</span>)<span class="comment">;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>由于malloc不对内存初始化，要初始化可以用strcpy():</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">strcpy</span>(p,<span class="string">"abc"</span>);<span class="comment">//注意：strcpy入口参数都是指针类型</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>using dynamic storage allocation in string function<br>比如要产生一个新的string，而这个string在程序运行的时候不存在，就可以用malloc来分配。</p>
</li>
<li>arrays of dynamically allocated strings</li>
</ul>
<h4 id="dynamically-allocated-arrays"><a href="#dynamically-allocated-arrays" class="headerlink" title="dynamically allocated arrays"></a>dynamically allocated arrays</h4><p>动态分配数组。如果数组的长度在程序运行之前为止，就可以动态分配，动态的分配可以按需分配，根据实际需求来分配。<br>例如，</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">int</span>* a=<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>这里，a是一个指针，但由于数组指针和数组关系，可以用a[i]来访问数组元素。</p>
<ul>
<li><p>the calloc function<br>语法：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> number,<span class="keyword">size_t</span> size)</span></span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>calloc就是天然为array而生的，就像malloc天然为string而生一样。calloc需要两个入口参数，一个是array元素个数，一个是每个元素包含的bytes数量。calloc还有一个优势，会自动对内存赋初值0.</p>
</li>
<li><p>the realloc function<br>语法：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>由于是对之前动态分配的内存的空间大小做调整，所以realloc需要知道这个空间的地址，ptr就是地址，而且一定是malloc,calloc,realloc得到的地址才可以。<br>另外需要说明的是：</p>
<blockquote>
<ul>
<li>如果size等于0，那就是free()的意思</li>
<li>如果给的指针是NULL指针,那就是malloc的意思</li>
<li>如果要expand a memory block, 由于是malloc的操作，所以不会initialize.</li>
<li>如果是expand,会首先在本地看是否有空间，如果没有，则重新开辟一个空间，然后复制现在的数据到新空间，返回新空间的地址。这个和c++中vector的操作很像啊。因此，需要更新相关的指针。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="deallocating-storage"><a href="#deallocating-storage" class="headerlink" title="deallocating storage"></a>deallocating storage</h4><p>内存的动态分配都是在heap中完成，如果只是分配而不释放，那么最后heap就没有空间可以分配。因此有必要对不需要的内存进行free()。在动态内存分配中，由于每一块内存都有一个指针来唯一指向，如果分配了内存，但是指针被搞丢了，也就是说指针内容被覆盖了，例如：</p>
<blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; p=malloc(...)<span class="comment">;</span></div><div class="line">&gt; q=malloc(...)<span class="comment">;</span></div><div class="line">&gt; p=q<span class="comment">;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面的例子就是把p的指针覆盖了，这样p指向的内存就无法访问，也无法释放。这种不能访问的内存叫garbage,这个现象就是所谓的memroy leak。一些高级的语言，例如Java就可以有garbage collector能自动回收内存，不需要操心。但c语言就需要程序员负责。例如：</p>
<blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; p=malloc(...)<span class="comment">;</span></div><div class="line">&gt; q=malloc(...)<span class="comment">;</span></div><div class="line">&gt; free(p)<span class="comment">;//先回收</span></div><div class="line">&gt; p=q<span class="comment">;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>The “Dangling Pointer” Problem</strong><br>这是一个使用动态内存分配很容易犯的错误。例如：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; p=<span class="built_in">malloc</span>(...);</div><div class="line">&gt; ...</div><div class="line">&gt; <span class="built_in">free</span>(p);</div><div class="line">&gt; ...</div><div class="line">&gt; <span class="built_in">strcpy</span>(p,<span class="string">"abc"</span>);<span class="comment">//错误！</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>我们先分配了一段内存，使用了然后释放了，这里注意释放这个空间，但这个空间的地址还保留在p里面，所以如果想使用这段空间，就会出现undefined behavior，这就是Dangling Pointer。上面的例子还容易发现p已经释放了。在很多大型的问题中，由于一块内存可能被多个指针指向，用其中任意指针都可以释放这块内存，这下我们就不容易看出指针指向的内存是否仍有效。原因，还是和内存直接打交道，太过于底层，太过于detail了，所以，需要细心.</p>
<h4 id="Linked-Lists"><a href="#Linked-Lists" class="headerlink" title="Linked Lists"></a>Linked Lists</h4><p>链表、树、图啊这些结构都需要用到动态内存分配。例如，我们新建一个链表，就要不断的产生新的节点。</p>
</li>
<li><p>declaring a node type<br>声明一个链表节点类型如下：</p>
<blockquote>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; struct <span class="keyword">node</span><span class="title">&#123;</span></div><div class="line">&gt;   int value;</div><div class="line">&gt;   struct <span class="keyword">node</span><span class="title">* next</span>;//注意类型是struct <span class="keyword">node</span><span class="title">*</span></div><div class="line">&gt;&#125;;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>需要说明的是，创建一个链表节点，只能用这种方式，不能用typedef.因为这个struct 有一个member是一个指向该struct的指针，至于为什么，还不是很清楚！</p>
</li>
<li><p>Create a node<br>这个node的内存是没有的，需要开辟空间，因此：</p>
<blockquote>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; struct <span class="keyword">node</span><span class="title">* new_node</span>=malloc(sizeof(struct <span class="keyword">node</span><span class="title">));</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>然后对开辟空间赋值：</p>
<blockquote>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; (*<span class="keyword">new</span><span class="number">_n</span>ode).<span class="keyword">value</span>=<span class="number">10</span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面用的*，还可以用-&gt;更直接：</p>
<blockquote>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">new</span><span class="number">_n</span>ode-&gt;<span class="keyword">value</span>=<span class="number">10</span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>insert&amp;delete a node(略)</p>
</li>
</ul>
<h4 id="Pointers-to-pointers"><a href="#Pointers-to-pointers" class="headerlink" title="Pointers to pointers"></a>Pointers to pointers</h4><p>指针的指针。指针已经算比较底层的处理问题、看待问题的工具或手段，那么指针的指针就是更底层的手段，我们之前也讨论过，指针的指针就相当于二阶求导数，可以在更多的细节上开展工作，解决问题，可以handle指针不能handle的问题，因此就表现得更灵活。由于太过细节、太过灵活，导致不好理解，而且操作步骤更多，更繁琐。这就是指针的指针的优缺点。我们每理解一个新问题，就应该尝试从至少两个角度看，有什么优点，看到优点，优点的反面就是缺点。不过优缺点都是相对的，要平等的对待。<br>指针的指针，以前讨论过即可以移动指向的位置，这个过程是不改变链表的结构，还可以修改指针的内容，这个过程就会改变链表的连接关系。适合头节点会改变的场合！</p>
<h4 id="Pointers-to-Functions"><a href="#Pointers-to-Functions" class="headerlink" title="Pointers to Functions"></a>Pointers to Functions</h4><p>这个脑洞就大了，既然指针可以指向变量，数组，动态分配内存，也就是说指针可以指向所有数据。一个程序，除了数据就是函数，那指针可以指向函数吗？指向函数有啥物理意义呢？指向函数肯定是可以的，因为在数据和函数在内存中都是放在某个位置的，从内存的角度看，不会区别到底是放的数据还是函数，所以，指针对数据和函数是公平对待的。<br>要说有什么物理意义，就不能从内存的底层角度看问题了，需要从上层看。<br>语法：</p>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; void (<span class="name">*pf</span>)(<span class="name">int</span>)<span class="comment">;//声明一个可以指向函数的pointer，指向的函数只有一个入口参数int,没有返回值。</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>如果现在就有一个这样的函数void f(int a);那就可以赋值给pf,让pf指向这个函数：</p>
<blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; pf=f<span class="comment">;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>注意：f单独出现，而后面不带括号，在编译器看来就是这个函数存在内存中的地址。这一点很好理解，我们学array的时候，编译器对array的名称也是认为代表这个array的地址。这一点是一致的。</p>
<ul>
<li>函数指针有什么用？<br>我们学过变量指针，知道指针和变量不是一个层次的，明确的说，指针比变量更底层，指针直接handle地址，而地址是存储器才有的。为什么handle地址就更灵活呢？我是这么理解的，用地址做变量的好处，就是地址可以在程序运行的时候改变，改变后，就可以从操作一个变量变成操作另一个变量，如果不用指针而直接用变量，在程序运行的时候只能修改变量内的值，但被操作的变量是固定不变的；类似的，函数指针也比函数还要底层，底层的元素虽然操作繁琐，需要考虑的细节很多，所获得的好处也很明显，更灵活，可以干更多的事情，就相当于微细加工，可以在细部着手。</li>
<li>书上举了两个例子：<blockquote>
<ul>
<li>第一个：把不同的命令，例如：new_cmd,open_cmd,close_cmd等，对应的函数的指针放在一个函数指针数组里，这样的好处是，我有函数指针，由于函数指针就是支持变化的，那么用调用那个函数就可以在程序运行中决定，就有点动态的味道了，难怪动态内存分配是返回的指针，就因为指针天然运行ontime的变化。再多说一句，如果想指针也发生变化，就需要指针的指针了，这个在链表中经常用到。<br>如下，我们现在调用函数就可以用(*file_cmd[i])()来调用了，i是可变的。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void (*file_cmd[])(void)=&#123;</div><div class="line">                    new_cmd<span class="comment">;</span></div><div class="line">                    open_cmd<span class="comment">;</span></div><div class="line">                    close_cmd<span class="comment">;</span></div><div class="line">                    save_cmd<span class="comment">;</span></div><div class="line">                    print_cmd<span class="comment">;</span></div><div class="line">                    exit_cmd<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>第二个：函数入口参数是另一个函数的运算结果，如果所调用的函数是固定的，这就是一般的应用，现在我们希望这个入口参数所调用的函数不再固定，希望可以在程序运行的过程中去调用不同的函数，这个时候也是用指针的最好时候，因为所谓指针就是支持在线改变嘛，支持动态的过程。</li>
</ul>
</blockquote>
<h3 id="看完17章，后面内容以后再更新！"><a href="#看完17章，后面内容以后再更新！" class="headerlink" title="看完17章，后面内容以后再更新！"></a>看完17章，后面内容以后再更新！</h3>]]></content>
      
        <categories>
            
            <category> 找工作 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试总结-2/21/2017]]></title>
      <url>https://ptbws.github.io/2017/02/22/%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>今天面试，面试前让看了一本gps书，看得很仔细的那种，自己还写了17页的pdf读书笔记，把书上的方法几乎都搞清楚了，就信心满满的去了，去了发现要现场做题，给了一页纸，就让作答，一看发现有一半不是书上的题，还有两个很开放的题，突然觉得这几天书白看了，自己看这么仔细，去了发现考的书上的知识都是很基本的，完全没必要看这么仔细。</p>
<p>当然看书也不亏，无意发现自己还可以喜欢看技术书，更发现一边看书一边写下自己的理解是一件很愉快的事。把一本厚厚的书按照自己的语言和习惯重新“写”一遍，这本书就不简单是原来那本书了，还加入了我自己读的时候的理解。无论理解的有没有到位，但这个记录过程就把自己读书的那时那刻的所思所想、肤浅的高深的都给摆在纸上，不藏着掖着，真实的面对看见自己在某一个时刻的思维的形状。</p>
<p>这儿记录一下印象深刻的问题：</p>
<blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Time_to_first_fix" target="_blank" rel="external">TTFF</a>: time to first fix. 这个书上没有，但干这个的人都知道，这就没办法，自己专业也不是这个。一查询，也不是啥高深的，就是gps第一次定位的时间，根据场景不同，分为cold start, warm start, hot start。</li>
<li>所谓cold start:就是卫星完全没有任何prior information. 需要一个一个的去捕获所有卫星，但捕获的时候，不是brute force.而是一旦捕获到一颗，就根据这颗卫星的信息，可知附近的卫星的位置，可以把这个信息用来帮助加快捕获其他卫星，而不用真正的全盲捕！这个思路也没什么高级的，但却是cold start最理想的方式，只有通过思考细节才能想到这个方法，也就是一颗卫星一颗卫星的来看，站在cold start的角度想。</li>
<li>warm start: 有prior data,例如：100km范围以内，20s时间以内等<ul>
<li>hot start： 就是当前的信息更清楚，比如:知道目前的位置坐标，目前的时间。</li>
</ul>
</li>
</ul>
</blockquote>
<p>另外还考了c语言的一些基础。发现自己好久不用不看c，很多基本问题都似是而非。看来，面试的时候，基础还是很重要，不能给别人感觉自己基础不扎实的感觉啊，因此，最近把c看了，然后把c++书再看看，尤其是自己不熟悉的章节，比如：继承。</p>
<p>另外一点，自己看面试，以为需要花很多时间把一些关键的问题搞得很透彻，而对一些不重要的问题很不上心，因为这些细枝末节很无趣没有挑战，而面试官却不这么看，他们没耐心去考察你是否透彻，他们主要关心你基础如何，能不能马上干活。所以，一个问题，涉及两个对象，两个对象对同一个问题理解就不一样。不一样不是因为两者看到的问题是两个问题。恰恰相反，两者看到的正是一个问题，只不过是一个问题的两个方面，每个人都习惯的从自己的立场去看这个问题，觉得理所当然。由于面试官是强势的一方，从而从面试官角度思考就显得重要了。以后，我应该做的是换个角度来看同一个问题，问题没变，是我调整了看他的角度，只是需要调整角度，问题就容易得到解决了。你看，观察多么重要！只要观察认可问题所在，而解决问题的方法就自然显露出来了！</p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 基础很重要 </tag>
            
            <tag> 不同的视角 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
